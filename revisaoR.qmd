# Uma pequena introdução ao R


## Introdução 

O `R` é peça-chave em inúmeros trabalhos de pesquisa e análise de dados porque reúne, de forma prática, um conjunto amplo de técnicas estatísticas atuais, das mais básicas às mais sofisticadas, e facilita seu uso no dia a dia. Quem começa no `R`, porém, muitas vezes também está dando os primeiros passos em programação. Assim, além de aprender as ferramentas do `R` para seus objetivos, é preciso desenvolver a “cabeça” de programador. Essa fase inicial ajuda a explicar a fama de que o `R` é “difícil”. Mesmo assim, com prática e uma boa orientação, ele se revela bem mais acessível do que parece.

## Instalação {.unnumbered}

Este guia mostra como **baixar e instalar o `R` a partir do CRAN** (Comprehensive R Archive Network), com orientações específicas para **Windows**, **macOS** e **Linux**. Ao final, você testará a instalação e configurará um **espelho (mirror) brasileiro** para baixar pacotes mais rápido.

::: callout-note
**O que é o CRAN?**  
É a rede oficial de servidores que distribui o `R` e seus pacotes. Você pode usar o endereço inteligente [https://cloud.r-project.org](https://cloud.r-project.org) ou definir um espelho no Brasil (ex.: C3SL/UFPR).
:::


Você pode simplesmente usar:

- **Cloud CRAN (recomendado):** [https://cloud.r-project.org](https://cloud.r-project.org) (redireciona para um espelho próximo).

- **Brasil (ex.: UFPR/C3SL):** [https://cran-r.c3sl.ufpr.br](https://cran-r.c3sl.ufpr.br)

Mais adiante, mostraremos como fixar o mirror no `R` permanentemente.

### Windows {.unnumbered}

1. Acesse a página **Download `R` for Windows** → **base** e baixe o instalador.

2. Execute o instalador e avance com as opções padrão (recomendado para iniciantes).

3. (Opcional) Se pretende **compilar pacotes a partir do código-fonte**, instale o **Rtools** compatível com a sua versão do `R`.

::: callout-tip
**Rtools:** após instalar, reinicie o R/RStudio. Em geral, o Rtools adiciona as ferramentas ao *PATH* automaticamente.
:::


### macOS {.unnumbered}

1. Acesse **`R` for macOS** no CRAN e baixe o arquivo `.pkg` da versão atual.

2. Abra o `.pkg` e conclua a instalação.

3. (Opcional) Para compilar pacotes, instale também as **Command Line Tools** do Xcode:

```bash
xcode-select --install
``` 

### Linux {.unnumbered}

**Ubuntu/Debian**

Opção rápida (repositório da distribuição):

```
sudo apt update
sudo apt install -y r-base
```

Para obter versões mais novas (repositório do CRAN), siga as instruções do CRAN para adicionar o repositório oficial e então:

```
sudo apt update
sudo apt install -y r-base r-base-dev
```

**Verificar a instalação**

No terminal/Prompt:

```
R --version
R
```

Dentro do R:

```{r}
version
```

Se o `R` abriu no console, a instalação está ok!


**Teste rápido de pacotes**

No R:

```{r}
#install.packages("tidyverse")   # teste de instalação/espelho
library(tidyverse)

tibble(x = 1:5, y = x^2)

```

Se o pacote instalou e carregou sem erros, está tudo certo.

#### Fixar um mirror brasileiro do CRAN {.unnumbered}

Defina o espelho apenas nesta sessão:

```{r}
#| eval: false

options(repos = c(CRAN = "https://cran-r.c3sl.ufpr.br"))
install.packages("ggplot2")
```

Para tornar **permanente**, adicione a linha abaixo ao seu arquivo `~/.Rprofile`:

```{r}
#| eval: false

options(repos = c(CRAN = "https://cloud.r-project.org"))
# ou, se preferir, o espelho da UFPR:
# options(repos = c(CRAN = "https://cran-r.c3sl.ufpr.br"))
```

#### Como editar o `~/.Rprofile` {.unnumbered}

- Linux/macOS:

```
echo 'options(repos = c(CRAN = "https://cloud.r-project.org"))' >> ~/.Rprofile
```

- Windows: o `~` normalmente aponta para `C:\\Users\\SEU_USUARIO\\Documents`.

Você pode criar/editar `C:\\Users\\SEU_USUARIO\\Documents\\.Rprofile` com um editor de texto.


#### (Opcional) IDE recomendada: RStudio {.unnumbered}

Após instalar o `R`, instale o `RStudio Desktop` (Posit) para um ambiente de desenvolvimento mais amigável:

- Criação/edição de scripts

- Gerenciamento de projetos

- Visualização de plots e help integrados

#### Dicas e solução de problemas {.unnumbered}

- **Permissões de administrador:** em ambientes corporativos, pode ser necessário pedir para TI instalar o `R`.

- **Firewall/Proxy:** se a instalação de pacotes falhar, verifique configurações de proxy e tente trocar o mirror.

- **Compatibilidade de versões:** ao compilar pacotes, garanta que as ferramentas (Rtools no Windows; CLT/Xcode no macOS) correspondam à sua versão do `R`.

- Atualização do `R`: ao atualizar o `R`, alguns pacotes precisarão ser reinstalados; use `install.packages()` novamente.

- **Testes mínimos:**

```{r}
sessionInfo()
capabilities()  # checa recursos gráficos, etc.
```


## O que é o `R` 

`R` é uma implementação moderna da linguagem `S`, voltada à computação estatística e à visualização de dados. Ele reúne, no mesmo lugar, um ambiente interativo para análise e criação de gráficos e uma linguagem de programação completa.

::: callout-note
**Em uma frase:** R é um ambiente estatístico + uma linguagem, criada para trabalhar bem com dados, gráficos e métodos modernos.
:::


#### Principais características {.unnumbered}

- **Interativo e interpretado**, com suporte a **JIT/bytecode** via pacote `compiler`.

- **Orientado a objetos** (S3, S4 e R6) e com forte base **funcional**.

- **Modelo “tudo é objeto”**: números, vetores, data frames, funções, ambientes e modelos ajustados.

- **Vetorização nativa** e operações matriciais eficientes.

- **Ecossistema de pacotes** amplo (CRAN, Bioconductor) para estatística e ciência de dados.

- **Extensível** com C/C++/Fortran e integração com Python, SQL e serviços externos.

- **Multiplataforma** (Windows, macOS, Linux) e foco em **reprodutibilidade** (scripts, Quarto/R Markdown).

#### Exemplo - "tudo é objeto"  {.unnumbered}

```{r}
#| label: exemplo-objeto
#| echo: true
#| message: false
#| warning: false

x <- 1:5               # vetor (objeto)
media <- mean(x)       # função aplicada ao objeto

f <- function(z) z^2
classe_f <- class(f)   # "function" — funções também são objetos

attr(x, "nota") <- "exemplo de atributo"
lista <- list(x = x, media = media, classe_f = classe_f)

str(lista)             # inspeciona a estrutura
lista
```


::: callout-tip
Dica: use `str(obj)` para entender a estrutura de qualquer objeto no `R`.

Outras funções úteis: `class()`, `attributes()`, `typeof()`, `methods(class = ...)`.
:::

Aqui vai como mudar o *prompt* do `R` para `R>`, na sessão atual usando:

```{r}
options(prompt = "R> ", continue = "+")
```

Para adicionar comentários no `R`, como você observou nos exemplos acima, basta usar `#`, como no exemplo abaixo:

```{r}
#Este é um comentário! 
#Que o semestre seja leve para todos nós!
```

Uma sessão ativa do `R` sempre está “apontando” para um diretório de trabalho. Se você não informar um caminho completo ao salvar ou importar arquivos, o `R` usará esse diretório por padrão. Para descobrir onde ele está:

```{r}
getwd()
```

Se você deseja modificar o diretório de trabalho, isso pode ser feito de maneira simples:

```{r}
#| eval: false

# Windows
setwd("C:/Users/SeuUsuario/Documents/meu-projeto")

# macOS / Linux
setwd("/Users/seuusuario/meu-projeto")

```


O `R` não vem com todos os pacotes adicionais que a comunidade desenvolve. Para usá-los, você precisa baixar e instalar a partir de um repositório, em geral, o CRAN.

```{r}
#| eval: false
# define um espelho (mirror) do CRAN para esta sessão
options(repos = c(CRAN = "https://cloud.r-project.org"))

# instala um ou mais pacotes
install.packages("tidyverse")
install.packages(c("ggplot2", "dplyr", "readr"))

# carrega para usar
library(tidyverse)
```

A instalação pode ser feita também facilmente usando o `RStudio`. 

Pacotes da comunidade são atualizados com frequência para corrigir erros e acrescentar recursos. Periodicamente, vale checar se há novas versões para o que você já tem instalado. A partir do console do `R`, você pode verificar e atualizar com um único comando.

```{r}
#| eval: false

# defina um mirror (opcional, mas recomendável)
options(repos = c(CRAN = "https://cloud.r-project.org"))

# procura versões mais novas e atualiza automaticamente
update.packages(ask = FALSE, checkBuilt = TRUE)
```

- `ask = FALSE` atualiza sem perguntar pacote a pacote.

- `checkBuilt = TRUE` recompila pacotes se sua versão do `R` mudou.

**Ver o que está desatualizado antes:**

```{r}
#| warning: false
#| message: false

old.packages()  # retorna uma tabela com pacotes que têm versão mais nova
```


**Atualizar apenas alguns pacotes:**

```{r}
#| eval: false

update.packages(oldPkgs = c("gamlss", "ggmap"), ask = FALSE)
```


O `R` traz um conjunto amplo de arquivos de ajuda que permitem:

- Buscar funcionalidades por nome ou por tema.

- Entender como usar uma função e quais argumentos ela recebe.

- Esclarecer o papel de cada argumento e o que a função retorna.

- Ver exemplos de uso prontos para rodar.

- Saber como citar o `R`, pacotes e conjuntos de dados em publicações.


Agora iremos ver algumas funções úteis:

- Ajuda com função específica:

```{r}
#| eval: false

?lm # atalho                  

help("lm") #abre a documentação da função

help(package = "stats") # índice de um pacote

```

- Buscar por tema (se você não sabe o nome exato):

```{r}
#| eval: false


??"linear model"        # busca por tópicos
help.search("normal")   # alternativa
apropos("plot")         # lista objetos cujo nome contém "plot"
```

- Ver argumentos e formas de chamada

```{r}
#| eval: false

args(lm)  # nomes dos argumentos (se aplicável)
formals(lm) # valores-padrão dos argumentos
```


- Exemplos, retorno e estrutura

```{r}
#| eval: false

example(lm) # roda os exemplos da ajuda
m <- lm(mpg ~ wt, data = mtcars)
str(m)                  # inspeciona o objeto retornado
methods("predict")      # métodos disponíveis para um genérico

```


- Vignettes (tutoriais)

```{r}
#| eval: false

vignette()  # lista geral
vignette(package = "ggplot2") # vignettes de um pacote
browseVignettes(package = "dplyr")  # abre no navegador
```


- Como citar R/pacotes/dados


```{r}
#| eval: true

citation()  # como citar o R
citation("ggplot2")   # como citar um pacote
toBibtex(citation("ggplot2"))  # em BibTeX 


```


- Conjuntos de dados


```{r}
data() # abre uma lista com os datasets disponíveis

# ?mtcars   # ajuda de um dataset específico
```


Console vs. editor:  Você pode digitar comandos diretamente no console ou escrever um script no editor e então executá-lo. Em materiais didáticos, distinguimos os dois formatos para evitar confusão.

1) Código mostrado com prompt `(R>)` = digitado no console

- Em livros/notas, comandos de console costumam aparecer com o prompt na frente.
Exemplo (divisão de 14 por 6):

```{r}
#| label: console-exemplo
#| eval: false
#| prompt: true
#| comment: NA
options(prompt = "R> ", continue = "+ ")
14/6
```

- Ao copiar para o `R`, remova o `R>`, o console já mostra o seu próprio prompt.

2) Código pensado para script (sem prompt)

- Quando o texto disser “escreva no editor e depois execute”, o código aparece sem `R>`.
Exemplo (laço simples):


```{r}
#| label: loop-no-editor
#| echo: true
for (myitem in 5:7) {
  cat("--INÍCIO DO BLOCO--\n")
  cat("o item atual é", myitem, "\n")
  cat("--FIM DO BLOCO--\n\n")
}
```

::: callout-tip
 **Dica de estilo:** chaves na mesma linha do for, quebra de linha para o corpo e indentação consistente.
::: 


3) Linhas longas: uma linha só ou “quebradas”

- Chamadas extensas podem ficar em uma linha ou ser quebradas em pontos naturais (geralmente após vírgulas ou antes de argumentos nomeados).

- Ao quebrar, alinhe com o parêntese de abertura ou indente um nível.

Uma linha:

```{r}
#| label: linha-unica
#| echo: true
ordfac.vec <- factor(x = c("Small","Large","Large","Regular","Small"),
                     levels = c("Small","Regular","Large"),
                     ordered = TRUE)

```

Quebrada (equivalente, apenas formatação):

```{r}
#| label: linha-quebrada
#| echo: true
ordfac.vec2 <-
  factor(
    x       = c("Small","Large","Large","Regular","Small"),
    levels  = c("Small","Regular","Large"),
    ordered = TRUE
  )
identical(ordfac.vec, ordfac.vec2)

```


##  Números, Aritmética, Atribuição e Vetores  

1) Números (*numerics*)

Em `R`, o tipo numérico padrão é **double** (ponto flutuante). Você também pode ter **inteiros** (sufixo `L`) e **complexos**.

```{r}
#| label: numerics-basico
#| echo: true
typeof(1)      # "double"
typeof(1L)     # "integer"
typeof(1+2i)   # "complex
```

- Valores especiais:

```{r}
#| echo: true
1/0  # Inf
-1/0 # -Inf
0/0  # NaN
is.finite(c(Inf, 3.14)) # checa finitude
```


::: callout-tip
Precisão numérica: comparações com `==` podem falhar por arredondamento binário. Prefira `all.equal(x, y)`.
:::

```{r}
#| label: precisao-numerica
#| echo: true
# 1) Exemplo clássico
x <- 0.1 + 0.2
y <- 0.3

x == y                       # pode dar FALSE
identical(x, y)              # compara "bit a bit": quase sempre FALSE aqui

# Ver a diferença real (use mais dígitos)
old <- options(digits = 17)
x; y; x - y                  # diferença minúscula de arredondamento binário
options(old)

# Comparação com tolerância
x;y
all.equal(x, y)              # Se “quase iguais”, retorna TRUE. Se diferem, retorna uma string explicando a diferença (ex.: "Mean relative difference: 1.2e-08").
isTRUE(all.equal(x, y))      # retorna um lógico (TRUE/FALSE)

# 2) Outros casos que sofrem com ponto flutuante
sin(pi)                      # ~ 1.224646799e-16 (não é 0 exato)
sin(pi) == 0                 # FALSE
all.equal(sin(pi), 0)        # TRUE

# 3) Ajustando a tolerância manualmente (quando precisar ser mais/menos rígido)
all.equal(x, y, tolerance = 1e-12)  # ainda TRUE
all.equal(x, y, tolerance = 1e-20)  # agora acusa diferença

# 4) Estratégia base sem all.equal: comparar o |erro| com um limite
abs((sqrt(2))^2 - 2) < 1e-12 # TRUE (aceita "igualdade" numérica com folga)

```


2) Aritmética

Operadores básicos: `+ - * / ^` e, ainda, divisão inteira `%/%` e módulo `%%`.


```{r}
#| label: aritmetica
#| echo: true
14/6
14 %/% 6 # quociente inteiro
14 %% 6 # resto
2^3  # potência
```


- Precedência: `^` → `* / %/% %%` → `+ -`. **Use parênteses para deixar claro!**

3) Atribuição

O padrão recomendado é `<-`. `=` também atribui, mas use-o preferencialmente para argumentos de função. `->` é atribuição para a direita. `<<-` afeta o ambiente pai (use com parcimônia).


```{r}
#| label: atribuicao
#| echo: true
x <- 10
y = 5   # ok, mas prefira <- fora de chamadas de função
z <- x + y

z -> resultado  # atribuição para a direita (menos comum)
resultado

# Exemplo de <<- (evite, pode dificultar depuração)
contador <- local({
  n <- 0
  function() { n <<- n + 1; n }
})
contador(); contador(); contador()

```


::: callout-warning
**Boas práticas:** Evite `<<-` sempre que possível; prefira retornar valores e trabalhar com escopos explícitos.
:::

4) Vetores (atômicos)

Vetores são coleções unidimensionais do mesmo tipo: lógico, inteiro, double, caractere, complexo ou raw.

```{r}
#| label: vetores-basico
#| echo: true
v <- c(2, 4, 6, 8)
length(v); typeof(v)

seq(1, 5, by = 2)      # sequência
1:5                    # atalho
rep(3, times = 4)      # repetição
```

- *Coerção automática:* ao misturar tipos, `R` promove para um tipo comum.

```{r}
#| echo: true
c(1, TRUE, "a") # tudo vira character
```

::: callout-warning
Quando você faz `c(1, TRUE, "a")`, o `R` precisa escolher um tipo comum para todos os elementos. A regra de coerção (promoção de tipos) segue, a grosso modo:

`logical` ⟶ `integer` ⟶ `double` ⟶ `complex` ⟶ `character`
:::


- Indexação e filtragem:

```{r}
#| label: indexacao
#| echo: true
x <- c(10, 20, 30, 40, 50)
x[3]             # posição
x[-1]            # tudo, exceto o 1º
x[x > 25]        # filtragem lógica
which(x > 25)    # posições TRUE
names(x) <- letters[1:5]
x["c"]
```

4.1. Vetorização e reciclagem

A maioria das operações é vetorizada (aplica-se elemento a elemento). Quando os comprimentos diferem, `R` tenta reciclar o menor vetor.


```{r}
#| label: vetorizacao
#| echo: true
a <- 1:5
b <- 10
a + b   # soma escalar-vetor (b é reciclado)

a + c(1, 2) # reciclagem com aviso (5 não é múltiplo de 2)
```



4.2. Nomes × Objetos e copy-on-modify

```{r}
#| label: copy-on-modify
#| echo: true
x <- 1:3
y <- x
y[1] <- 99
x  # permanece 1 2 3
y  # 99 2 3
```

::: callout-warning
Exceção: ambientes e estruturas por referência (p.ex., R6) não seguem copy-on-modify.
:::

### Exercícios  {.unnumbered}

1. Crie um vetor com os números de `5` a `15` e calcule a média.

2. Use `seq()` para gerar `0, 0.5, 1,..., 5`.

3. Mostre com código a diferença entre `%/%` e `%%` usando 14 e 6.

4. Atribua `x <- 1:4` e some com o vetor `c(10, 20)`. O que acontece?

5. Verifique o tipo de `1`, `1L` e `1+0i`. Explique a diferença entre tipo (typeof) e classe (class).

6. Crie e armazene uma sequência de valores de `5 a −11`, progredindo em `passos de 0.3`.

7. Reescreva o objeto de (6) com a mesma sequência invertida.

8. Repita o vetor `c(-1, 3, -5, 7, -9)` duas vezes, com cada elemento repetido 10 vezes.
Apresente os dados ordenados do maior para o menor.

9. Crie e armazene um vetor contendo, em qualquer ordem:

a) inteiros de `6` a `12` (inclusive);

b) `5.3` repetido 3 vezes;

c) o número `−3`;

d) Uma sequência de nove valores começando em `102` e terminando no número que é o comprimento total do vetor criado em (8).

10. Confirme que o comprimento do vetor criado em (9) é 20.

<!-- ## Estrutura Lógicas {.unnumbered} -->

<!-- ## Estruturas de Controle {.unnumbered} -->

<!-- ## Funções {.unnumbered} -->

<!-- ## Distribuições de Probabilidade {.unnumbered} -->

## Matrizes 

A matriz é uma construção matemática importante e é essencial para muitos métodos estatísticos. Normalmente descreve-se uma matriz $A$ como uma matriz $m \times n$; isto é, $A$ terá exatamente $m$ linhas e $n$ colunas. Isso significa que $A$ terá um total de $mn$ entradas, com cada entrada a $i, j$ ocupando uma posição única dada por sua linha específica $(i = 1, 2,\dots, m)$ e coluna $(j = 1, 2,\dots, n)$.


Para criar uma matriz no `R`, use o comando, apropriadamente chamado, `matrix`, fornecendo as entradas da matriz ao argumento `data` como um vetor:

```{r}
A <- matrix(
     data = c(-3, 2, 893, 0.17),
     nrow = 2, #linha
     ncol = 2  #colunas
     )


A
```


É importante estar ciente de como o `R` preenche a matriz usando as entradas de `data`. Observando o exemplo anterior, você pode ver que a matriz $A$ foi preenchida coluna por coluna ao ler as entradas de dados da esquerda para a direita. Você pode controlar como o `R` preenche os dados usando o argumento `byrow`, como mostrado nos exemplos a seguir:


```{r}
matrix(data = c(1,2,3,4,5,6), nrow = 2, ncol = 3, byrow = FALSE)
```

Qual a diferença na construção da matriz ao usar `byrow = TRUE`?


Também é possível construir matrizes usando os comandos `cbind` e `rbind`. Veja os exemplos abaixo:

```{r}
cbind(c(1,4), c(2,5), c(3,6))
rbind(1:3,4:6)
```

Para saber a dimensão, número de linhas e colunas de uma matriz você pode usar os seguintes comandos:

```{r}
dim(A); nrow(A); ncol(A)
```

Considere a seguinte matriz:

```{r}
A <- matrix(c(0.3, 4.5, 55.3, 91, 0.1, 105.5, -4.2, 8.2, 27.9), nrow = 3, ncol = 3)

A
```


Para dizer ao `R` para “olhar para a terceira linha de $A$ e me dar o elemento da
segunda coluna”, você executa o seguinte:


```{r}
A[3, 2]
```

Como esperado, você recebe o elemento na posição $[3,2]$.

Você também pode identificar os valores ao longo da diagonal de uma matriz quadrada (isto é, uma matriz com igual número de linhas e colunas) usando o comando `diag`.

```{r}
diag(A)
```



### Exercícios {.unnumbered}

**(a)** Construa e armazene uma matriz $4 \times 2$ preenchida **por linhas** com os valores:  4.3, 3.1, 8.2, 8.2, 3.2, 0.9, 1.6 e 6.5 (nessa ordem).


```{r}
A <- matrix(c(4.3, 3.1, 8.2, 8.2, 3.2, 0.9, 1.6, 6.5), nrow = 4, byrow = TRUE); A
```

**(b)** Confirme que as dimensões da matriz do item (a) são $3 \times 2$ se você remover qualquer uma das linhas.

```{r}
matrix_test_32 <- function(data){

v_saida <- NULL
for(i in 1:nrow(data)){

v_saida[i] <- all(dim(data[-i, , drop = FALSE]) == c(3,2))       
}       

sprintf( "A matriz é 3x2? %s", ifelse(all(v_saida) == TRUE, "Sim", "Não" ) )   
} 


matrix_test_32(A)

B <- matrix(c(1,2,3,4), ncol = 2); B

matrix_test_32(B)

```



**(c)** Sobrescreva a **segunda coluna** da matriz do item (a) com essa mesma coluna **ordenada do menor para o maior**.

**(d)** O que o `R` retorna se você excluir a **quarta linha** e a **primeira coluna** do item (c)? Use `matrix` para garantir que o resultado seja uma **matriz de uma única coluna**, e não um vetor.

**(e)** Armazene os **quatro elementos inferiores** do item (c) como uma nova matriz $2 \times 2$.

**(f)** Sobrescreva, **nesta ordem**, os elementos do item (c) nas posições $(4, 2), (1, 2), (4, 1)$ e $(1, 1)$ com $-\tfrac{1}{2}$ dos dois valores na **diagonal do item (e)**.


## Operações com matrizes 

Em `R`, a transposta de uma matriz se obtém com `t()`, ela troca linhas por colunas.

```{r}
A <- rbind(c(2,5,2),c(6,1,4))

t(A)
```

Você pode criar uma matriz identidade de qualquer dimensão usando a função `matrix`, mas há uma forma mais rápida usando `diag`. Antes, usei `diag` em uma matriz existente para extrair ou sobrescrever seus elementos da diagonal. Você também pode usá-la assim:

```{r}
I4 <- diag(4) # 4x4
I4


I5 <- diag(1, nrow = 5, ncol = 5) #forma explicita
I5
```

O `R` realizará essa multiplicação de maneira elemento a elemento, como você poderia esperar. A multiplicação escalar de uma matriz é realizada usando o operador aritmético padrão `*`.

```{r}
A <- rbind(c(2,5,2) , c(6,1,4))
a <- 2

a*A
```

Você pode somar ou subtrair quaisquer duas matrizes de mesmo tamanho usando os símbolos padrão `+` e `-`.

```{r}
A <- cbind(c(2,5,2), c(6,1,4))

A

B <-  cbind(c(-2,3,6), c(8.1,8.2,-9.8))

B

A - B

A + B 
```

Ao contrário da adição, subtração e multiplicação escalar, a multiplicação de matrizes não é um cálculo elemento a elemento, e o operador padrão `*` não pode ser usado. Em vez disso, você deve usar o operador de produto matricial do `R`, escrito com símbolos de porcentagem como `%*%`. Antes de tentar esse operador, vamos primeiro armazenar as duas matrizes de exemplo e verificar se o número de colunas na primeira matriz corresponde ao número de linhas na segunda matriz usando `dim`.


```{r}
A <- rbind(c(2,5,2), c(6,1,4))

dim(A)

B <-  cbind(c(3,-1,1), c(-3,1,5))

dim(B)
```

Isso confirma que as duas matrizes são compatíveis para a multiplicação, então você pode prosseguir.


```{r}
A%*%B
```

Você pode mostrar que a multiplicação de matrizes é **não comutativa** usando as mesmas duas matrizes. Inverter a ordem da multiplicação produz um resultado completamente diferente.

```{r}
B%*%A
```


Matrizes que não são invertíveis são chamadas de singulares. Inverter uma matriz é frequentemente necessário ao resolver sistemas de equações e tem implicações práticas importantes. Há vários métodos para inversão, e o custo computacional cresce muito à medida que o tamanho da matriz aumenta. Não entraremos em detalhes aqui; para discussões formais, veja Golub e Van Loan (1989). Por ora, veja a função `solve` do `R` como uma opção para inverter matrizes.

```{r}
A <- matrix(data = c(3, 4, 1, 2), nrow = 2, ncol = 2)

A

solve(A)
```

Você também pode verificar que o produto dessas duas matrizes (usando as regras de multiplicação de matrizes) resulta na matriz identidade $2 \times 2$

```{r}
A %*% solve(A)
```


### Exercícios {.unnumbered}

**(a)** Calcule

$$
\frac{2}{7}\left(
\begin{bmatrix}1 & 2\\2 & 4 \\ 7 & 6\end{bmatrix}
-
\begin{bmatrix}10 & 20\\30 & 40 \\ 50 & 60\end{bmatrix}
\right).
$$

**(b)** Armazene as duas matrizes abaixo:

$$
A=\begin{bmatrix}1\\2\\7\end{bmatrix},
\quad
B=\begin{bmatrix}3\\4\\8\end{bmatrix}.
$$

Quais das multiplicações a seguir são possíveis? Para as que forem, calcule o resultado.

i. $A \cdot B$;

ii. $A^{\top} \cdot B$;

iii. $B^{\top} \cdot (A \cdot A^{\top})$;

iv. $(A \cdot A^{\top}) \cdot B^{\top}$;

v. $\big[(B \cdot B^{\top}) + (A \cdot A^{\top}) - 100\,I_{3}\big]^{-1}$.


**(c)** Para

$$
A = \begin{bmatrix}
2&0&0&0\\
0&3&0&0\\
0&0&5&0\\
0&0&0&-1
\end{bmatrix},
$$

confirme que $A^{-1}\cdot A - I_{4}$ fornece uma matriz $4\times 4$ de zeros.


## Laços e repetições

O laço clássico, ao estilo Fortran, está disponível no `R`. A sintaxe é um pouco diferente, mas a ideia é idêntica: você pede que um índice, $i$, assuma uma sequência de valores, e que uma ou mais linhas de comandos sejam executadas tantas vezes quantos forem os valores distintos de $i$. A seguir, um laço executado cinco vezes com $i$ de $1$ a $5$; imprimimos o quadrado de cada valor:

```{r}
for(i in 1:5) print(i^2)
```

Para várias linhas de código, você usa chaves `{}` para incluir o material sobre o qual o laço deve atuar.
Note que a “quebra de linha” (pressionar a tecla Enter) ao final de cada comando é uma parte essencial da estrutura (você pode substituir as quebras de linha por ponto e vírgula, se preferir, mas a clareza melhora se cada comando for colocado em uma linha separada).

```{r}
j <- k <- 0
for(i in 1:5){
j <- j + 1
k <- k + i*j
print(i + j + k)
}
```

O fatorial de um número inteiro $x$ (escrito $x!$) é o produto de todos os inteiros positivos de $1$ até $x$. Por definição:

$$x! = x \times (x-1) \times (x-2) \times (x-3)\dots \times 2 \times 1.$$
Por exemplo, $4! = 4\times 3 \times 2 \times 1 = 24$. Aqui está a função:

```{r}
fac1 <- function(x){
f <- 1
if(x < 2) return(1)
  for(i in 2:x){
    f <- f*i
  }
f
}
```

Parece complicado para uma tarefa simples. Mas vamos testar de 0 a 5:

```{r}
sapply(0:5, fac1)
```

Existem outras duas funções de laço no `R`: `repeat` e `while`. Vamos demonstrar seu uso para fins de ilustração, mas podemos fazer bem melhor ao escrever uma função compacta para calcular fatoriais (veja abaixo). Primeiro, a função `while`:

```{r}
fac2 <- function(x){
  f <- 1
  t <- x
  while(t > 1){
    f <- f*t
    t <- t - 1
  }
  return(f)
}
```

Agora iremos testar a função para os números inteiros de 0 a 5:

```{r}
sapply(0:5, fac2)
```

::: callout-warning
## O ponto central

o `while` sozinho não gera a sequência; você precisa configurar e atualizar manualmente uma variável de controle (aqui `t`). Isso torna o `while` menos compacto do que `for`, mas útil quando você não sabe de antemão quantas iterações serão necessárias.
:::

Por fim, vamos mostrar o uso da função `repeat`:

```{r}
fac3 <- function(x){
  f <- 1
  t <- x
  repeat{
    if(t<2) break
    f <- f*t
    t <- t - 1
  }
  return(f)
}
```

O `repeat` em `R` não tem um fim explícito, ele vai rodar para sempre a menos que você coloque uma condição de saída que use `break`. 

```{r}
sapply(0:5,fac3)
```

É uma boa prática de programação em `R` evitar o uso de laços sempre que possível. O uso de funções vetorizadas torna isso particularmente simples em muitos casos. Suponha que você queira substituir todos os valores negativos de um array por zeros. Você poderia ter escrito algo assim:

```{r}
#| eval: false
for(i in 1:length(y)){
  if(y[i] < 0) y[i] <- 0
}
```

No entanto, você pode simplesmente fazer assim:

```{r}
#| eval: false

y[y<0] <- 0
```

Às vezes você quer fazer uma coisa se uma condição for verdadeira e outra diferente se a condição for falsa (em vez de não fazer nada, como no exemplo anterior). A função `ifelse` permite fazer isso em vetores inteiros sem precisar usar laços com `for`. Por exemplo, podemos querer substituir qualquer valor negativo de `y` por `–1` e qualquer valor positivo ou zero por `+1`:

```{r}
y <- c(-5, -1, 0, 2, 7)
ifelse(y < 0, -1, 1)
```

## Escrevendo funções no `R`


Normalmente você escreve funções em `R` para realizar operações que exigem duas ou mais linhas de código para serem executadas, e que você não quer digitar várias vezes. Podemos querer escrever funções simples para calcular medidas de tendência central, calcular fatoriais e coisas do tipo.

Funções em `R` são objetos que realizam operações sobre argumentos que lhes são fornecidos e retornam um ou mais valores. A sintaxe para escrever uma função é

```{r}
#| eval: false

function(lista_de_argumentos){
  # corpo da função
  # instruções
  return(valor)
}
```

O primeiro componente da declaração de função é a palavra-chave `function`, que indica ao `R` que você quer criar uma função.

Uma **lista de argumentos** é uma lista separada por vírgulas de **argumentos formais**. Um argumento formal pode ser:

- um símbolo (isto é, um nome de variável como `x` ou `y`),

- uma declaração do tipo `símbolo = expressão` (por exemplo, `pch = 16`),

- ou o argumento especial `...` (três pontos), que permite passar múltiplos argumentos adicionais.

O corpo pode ser qualquer expressão válida em `R` ou um conjunto de expressões em uma ou mais linhas. Em geral, o corpo é um grupo de expressões dentro de chaves `{ }`, com cada expressão em uma linha separada (se o corpo couber em uma linha, as chaves não são necessárias).

Funções normalmente são atribuídas a símbolos (variáveis), mas isso não é obrigatório. Esse conceito só começa a fazer sentido depois de ver vários exemplos em funcionamento.

### Média Aritmética

A média é a soma dos valores $y_i$ dividida pela quantidade
de valores $n$ (somando ao longo do número de elementos do vetor $y$). Em `R`, $n =$`length(y)` e $\sum y =$`sum(y)`. 
Assim, uma função para calcular a média aritmética é:

```{r}
media_aritmetica <- function(x) sum(x)/length(x)
```

Vamos testar a função com dados em que sabemos de antemão qual deve ser o resultado.


```{r}
y <- c(3, 3, 4, 5, 5)
media_aritmetica(y)
```

### Mediana

A mediana (ou 50º percentil) é o valor do meio dos valores ordenados de um vetor de números:

```{r}
#| eval: false
sort(y)[ceiling(length(y)/2)]
```

Há, é claro, um pequeno problema aqui, porque se o vetor contém um número par de números, então não existe valor do meio. A lógica aqui é que precisamos calcular a média aritmética dos dois valores de `y` em cada lado do meio. Surge agora a questão de como sabemos, em geral, se o vetor contém um número ímpar ou par de números, de modo que possamos decidir qual dos dois métodos usar. O truque aqui é usar o módulo 2. Agora temos todas as ferramentas de que precisamos para escrever uma função geral para calcular medianas. Vamos chamar a função de `mediana` e defini-la assim:

```{r}
mediana <- function(x){
  impar_par <- length(x)%%2
  if(impar_par == 0) (sort(x)[length(x)/2] + sort(x)[1 + length(x)/2])/2
  else sort(x)[ceiling(length(x)/2)]
}
```

Vamos agora testar a função:

```{r}
mediana(y)
```

### Exercícios {.unnumbered}

1. Crie sua própria função que calcula a variância, o desvio-padrão e o coeficiente de variação.

2. Crie uma função para listar os elementos de uma série de Fibonacci ($1, 1, 2, 3, 5, 8, \dots$).

3. Crie uma função para calcular fatoriais usando o comando `cumprod`. 

4. Crie sua própria função para calcular a mediana.

5. Crie sua própria função para calcular a média.


