# Uma pequena introdução ao R


## Introdução {.unnumbered}

O `R` é peça-chave em inúmeros trabalhos de pesquisa e análise de dados porque reúne, de forma prática, um conjunto amplo de técnicas estatísticas atuais, das mais básicas às mais sofisticadas, e facilita seu uso no dia a dia. Quem começa no `R`, porém, muitas vezes também está dando os primeiros passos em programação. Assim, além de aprender as ferramentas do `R` para seus objetivos, é preciso desenvolver a “cabeça” de programador. Essa fase inicial ajuda a explicar a fama de que o `R` é “difícil”. Mesmo assim, com prática e uma boa orientação, ele se revela bem mais acessível do que parece.

## Instalação {.unnumbered}

Este guia mostra como **baixar e instalar o `R` a partir do CRAN** (Comprehensive R Archive Network), com orientações específicas para **Windows**, **macOS** e **Linux**. Ao final, você testará a instalação e configurará um **espelho (mirror) brasileiro** para baixar pacotes mais rápido.

::: callout-note
**O que é o CRAN?**  
É a rede oficial de servidores que distribui o `R` e seus pacotes. Você pode usar o endereço inteligente [https://cloud.r-project.org](https://cloud.r-project.org) ou definir um espelho no Brasil (ex.: C3SL/UFPR).
:::


Você pode simplesmente usar:

- **Cloud CRAN (recomendado):** [https://cloud.r-project.org](https://cloud.r-project.org) (redireciona para um espelho próximo).

- **Brasil (ex.: UFPR/C3SL):** [https://cran-r.c3sl.ufpr.br](https://cran-r.c3sl.ufpr.br)

Mais adiante, mostraremos como fixar o mirror no `R` permanentemente.

### Windows {.unnumbered}

1. Acesse a página **Download `R` for Windows** → **base** e baixe o instalador.

2. Execute o instalador e avance com as opções padrão (recomendado para iniciantes).

3. (Opcional) Se pretende **compilar pacotes a partir do código-fonte**, instale o **Rtools** compatível com a sua versão do `R`.

::: callout-tip
**Rtools:** após instalar, reinicie o R/RStudio. Em geral, o Rtools adiciona as ferramentas ao *PATH* automaticamente.
:::


### macOS {.unnumbered}

1. Acesse **`R` for macOS** no CRAN e baixe o arquivo `.pkg` da versão atual.

2. Abra o `.pkg` e conclua a instalação.

3. (Opcional) Para compilar pacotes, instale também as **Command Line Tools** do Xcode:

```bash
xcode-select --install
``` 

### Linux {.unnumbered}

**Ubuntu/Debian**

Opção rápida (repositório da distribuição):

```
sudo apt update
sudo apt install -y r-base
```

Para obter versões mais novas (repositório do CRAN), siga as instruções do CRAN para adicionar o repositório oficial e então:

```
sudo apt update
sudo apt install -y r-base r-base-dev
```

**Verificar a instalação**

No terminal/Prompt:

```
R --version
R
```

Dentro do R:

```{r}
version
```

Se o `R` abriu no console, a instalação está ok!


**Teste rápido de pacotes**

No R:

```{r}
#install.packages("tidyverse")   # teste de instalação/espelho
library(tidyverse)

tibble(x = 1:5, y = x^2)

```

Se o pacote instalou e carregou sem erros, está tudo certo.

#### Fixar um mirror brasileiro do CRAN {.unnumbered}

Defina o espelho apenas nesta sessão:

```{r}
#| eval: false

options(repos = c(CRAN = "https://cran-r.c3sl.ufpr.br"))
install.packages("ggplot2")
```

Para tornar **permanente**, adicione a linha abaixo ao seu arquivo `~/.Rprofile`:

```{r}
#| eval: false

options(repos = c(CRAN = "https://cloud.r-project.org"))
# ou, se preferir, o espelho da UFPR:
# options(repos = c(CRAN = "https://cran-r.c3sl.ufpr.br"))
```

#### Como editar o `~/.Rprofile` {.unnumbered}

- Linux/macOS:

```
echo 'options(repos = c(CRAN = "https://cloud.r-project.org"))' >> ~/.Rprofile
```

- Windows: o `~` normalmente aponta para `C:\\Users\\SEU_USUARIO\\Documents`.

Você pode criar/editar `C:\\Users\\SEU_USUARIO\\Documents\\.Rprofile` com um editor de texto.


#### (Opcional) IDE recomendada: RStudio {.unnumbered}

Após instalar o `R`, instale o `RStudio Desktop` (Posit) para um ambiente de desenvolvimento mais amigável:

- Criação/edição de scripts

- Gerenciamento de projetos

- Visualização de plots e help integrados

#### Dicas e solução de problemas {.unnumbered}

- **Permissões de administrador:** em ambientes corporativos, pode ser necessário pedir para TI instalar o `R`.

- **Firewall/Proxy:** se a instalação de pacotes falhar, verifique configurações de proxy e tente trocar o mirror.

- **Compatibilidade de versões:** ao compilar pacotes, garanta que as ferramentas (Rtools no Windows; CLT/Xcode no macOS) correspondam à sua versão do `R`.

- Atualização do `R`: ao atualizar o `R`, alguns pacotes precisarão ser reinstalados; use `install.packages()` novamente.

- **Testes mínimos:**

```{r}
sessionInfo()
capabilities()  # checa recursos gráficos, etc.
```


## O que é o `R` {.unnumbered}

`R` é uma implementação moderna da linguagem `S`, voltada à computação estatística e à visualização de dados. Ele reúne, no mesmo lugar, um ambiente interativo para análise e criação de gráficos e uma linguagem de programação completa.

::: callout-note
**Em uma frase:** R é um ambiente estatístico + uma linguagem, criada para trabalhar bem com dados, gráficos e métodos modernos.
:::


#### Principais características {.unnumbered}

- **Interativo e interpretado**, com suporte a **JIT/bytecode** via pacote `compiler`.

- **Orientado a objetos** (S3, S4 e R6) e com forte base **funcional**.

- **Modelo “tudo é objeto”**: números, vetores, data frames, funções, ambientes e modelos ajustados.

- **Vetorização nativa** e operações matriciais eficientes.

- **Ecossistema de pacotes** amplo (CRAN, Bioconductor) para estatística e ciência de dados.

- **Extensível** com C/C++/Fortran e integração com Python, SQL e serviços externos.

- **Multiplataforma** (Windows, macOS, Linux) e foco em **reprodutibilidade** (scripts, Quarto/R Markdown).

#### Exemplo - "tudo é objeto"  {.unnumbered}

```{r}
#| label: exemplo-objeto
#| echo: true
#| message: false
#| warning: false

x <- 1:5               # vetor (objeto)
media <- mean(x)       # função aplicada ao objeto

f <- function(z) z^2
classe_f <- class(f)   # "function" — funções também são objetos

attr(x, "nota") <- "exemplo de atributo"
lista <- list(x = x, media = media, classe_f = classe_f)

str(lista)             # inspeciona a estrutura
lista
```


::: callout-tip
Dica: use `str(obj)` para entender a estrutura de qualquer objeto no `R`.

Outras funções úteis: `class()`, `attributes()`, `typeof()`, `methods(class = ...)`.
:::

Aqui vai como mudar o *prompt* do `R` para `R>`, na sessão atual usando:

```{r}
options(prompt = "R> ", continue = "+")
```

Para adicionar comentários no `R`, como você observou nos exemplos acima, basta usar `#`, como no exemplo abaixo:

```{r}
#Este é um comentário! 
#Que o semestre seja leve para todos nós!
```

Uma sessão ativa do `R` sempre está “apontando” para um diretório de trabalho. Se você não informar um caminho completo ao salvar ou importar arquivos, o `R` usará esse diretório por padrão. Para descobrir onde ele está:

```{r}
getwd()
```

Se você deseja modificar o diretório de trabalho, isso pode ser feito de maneira simples:

```{r}
#| eval: false

# Windows
setwd("C:/Users/SeuUsuario/Documents/meu-projeto")

# macOS / Linux
setwd("/Users/seuusuario/meu-projeto")

```


O `R` não vem com todos os pacotes adicionais que a comunidade desenvolve. Para usá-los, você precisa baixar e instalar a partir de um repositório, em geral, o CRAN.

```{r}
#| eval: false
# define um espelho (mirror) do CRAN para esta sessão
options(repos = c(CRAN = "https://cloud.r-project.org"))

# instala um ou mais pacotes
install.packages("tidyverse")
install.packages(c("ggplot2", "dplyr", "readr"))

# carrega para usar
library(tidyverse)
```

A instalação pode ser feita também facilmente usando o `RStudio`. 

Pacotes da comunidade são atualizados com frequência para corrigir erros e acrescentar recursos. Periodicamente, vale checar se há novas versões para o que você já tem instalado. A partir do console do `R`, você pode verificar e atualizar com um único comando.

```{r}
#| eval: false

# defina um mirror (opcional, mas recomendável)
options(repos = c(CRAN = "https://cloud.r-project.org"))

# procura versões mais novas e atualiza automaticamente
update.packages(ask = FALSE, checkBuilt = TRUE)
```

- `ask = FALSE` atualiza sem perguntar pacote a pacote.

- `checkBuilt = TRUE` recompila pacotes se sua versão do `R` mudou.

**Ver o que está desatualizado antes:**

```{r}
#| warning: false
#| message: false

old.packages()  # retorna uma tabela com pacotes que têm versão mais nova
```


**Atualizar apenas alguns pacotes:**

```{r}
#| eval: false

update.packages(oldPkgs = c("gamlss", "ggmap"), ask = FALSE)
```


O `R` traz um conjunto amplo de arquivos de ajuda que permitem:

- Buscar funcionalidades por nome ou por tema.

- Entender como usar uma função e quais argumentos ela recebe.

- Esclarecer o papel de cada argumento e o que a função retorna.

- Ver exemplos de uso prontos para rodar.

- Saber como citar o `R`, pacotes e conjuntos de dados em publicações.


Agora iremos ver algumas funções úteis:

- Ajuda com função específica:

```{r}
#| eval: false

?lm # atalho                  

help("lm") #abre a documentação da função

help(package = "stats") # índice de um pacote

```

- Buscar por tema (se você não sabe o nome exato):

```{r}
#| eval: false


??"linear model"        # busca por tópicos
help.search("normal")   # alternativa
apropos("plot")         # lista objetos cujo nome contém "plot"
```

- Ver argumentos e formas de chamada

```{r}
#| eval: false

args(lm)  # nomes dos argumentos (se aplicável)
formals(lm) # valores-padrão dos argumentos
```


- Exemplos, retorno e estrutura

```{r}
#| eval: false

example(lm) # roda os exemplos da ajuda
m <- lm(mpg ~ wt, data = mtcars)
str(m)                  # inspeciona o objeto retornado
methods("predict")      # métodos disponíveis para um genérico

```


- Vignettes (tutoriais)

```{r}
#| eval: false

vignette()  # lista geral
vignette(package = "ggplot2") # vignettes de um pacote
browseVignettes(package = "dplyr")  # abre no navegador
```


- Como citar R/pacotes/dados


```{r}
#| eval: true

citation()  # como citar o R
citation("ggplot2")   # como citar um pacote
toBibtex(citation("ggplot2"))  # em BibTeX 


```


- Conjuntos de dados


```{r}
data() # abre uma lista com os datasets disponíveis

# ?mtcars   # ajuda de um dataset específico
```


Console vs. editor:  Você pode digitar comandos diretamente no console ou escrever um script no editor e então executá-lo. Em materiais didáticos, distinguimos os dois formatos para evitar confusão.

1) Código mostrado com prompt `(R>)` = digitado no console

- Em livros/notas, comandos de console costumam aparecer com o prompt na frente.
Exemplo (divisão de 14 por 6):

```{r}
#| label: console-exemplo
#| eval: false
#| prompt: true
#| comment: NA
options(prompt = "R> ", continue = "+ ")
14/6
```

- Ao copiar para o `R`, remova o `R>`, o console já mostra o seu próprio prompt.

2) Código pensado para script (sem prompt)

- Quando o texto disser “escreva no editor e depois execute”, o código aparece sem `R>`.
Exemplo (laço simples):


```{r}
#| label: loop-no-editor
#| echo: true
for (myitem in 5:7) {
  cat("--INÍCIO DO BLOCO--\n")
  cat("o item atual é", myitem, "\n")
  cat("--FIM DO BLOCO--\n\n")
}
```

::: callout-tip
 **Dica de estilo:** chaves na mesma linha do for, quebra de linha para o corpo e indentação consistente.
::: 


3) Linhas longas: uma linha só ou “quebradas”

- Chamadas extensas podem ficar em uma linha ou ser quebradas em pontos naturais (geralmente após vírgulas ou antes de argumentos nomeados).

- Ao quebrar, alinhe com o parêntese de abertura ou indente um nível.

Uma linha:

```{r}
#| label: linha-unica
#| echo: true
ordfac.vec <- factor(x = c("Small","Large","Large","Regular","Small"),
                     levels = c("Small","Regular","Large"),
                     ordered = TRUE)

```

Quebrada (equivalente, apenas formatação):

```{r}
#| label: linha-quebrada
#| echo: true
ordfac.vec2 <-
  factor(
    x       = c("Small","Large","Large","Regular","Small"),
    levels  = c("Small","Regular","Large"),
    ordered = TRUE
  )
identical(ordfac.vec, ordfac.vec2)

```


##  Números, Aritmética, Atribuição e Vetores  {.unnumbered}

1) Números (*numerics*)

Em `R`, o tipo numérico padrão é **double** (ponto flutuante). Você também pode ter **inteiros** (sufixo `L`) e **complexos**.

```{r}
#| label: numerics-basico
#| echo: true
typeof(1)      # "double"
typeof(1L)     # "integer"
typeof(1+2i)   # "complex
```

- Valores especiais:

```{r}
#| echo: true
1/0  # Inf
-1/0 # -Inf
0/0  # NaN
is.finite(c(Inf, 3.14)) # checa finitude
```


::: callout-tip
Precisão numérica: comparações com `==` podem falhar por arredondamento binário. Prefira `all.equal(x, y)`.
:::

```{r}
#| label: precisao-numerica
#| echo: true
# 1) Exemplo clássico
x <- 0.1 + 0.2
y <- 0.3

x == y                       # pode dar FALSE
identical(x, y)              # compara "bit a bit": quase sempre FALSE aqui

# Ver a diferença real (use mais dígitos)
old <- options(digits = 17)
x; y; x - y                  # diferença minúscula de arredondamento binário
options(old)

# Comparação com tolerância
x;y
all.equal(x, y)              # Se “quase iguais”, retorna TRUE. Se diferem, retorna uma string explicando a diferença (ex.: "Mean relative difference: 1.2e-08").
isTRUE(all.equal(x, y))      # retorna um lógico (TRUE/FALSE)

# 2) Outros casos que sofrem com ponto flutuante
sin(pi)                      # ~ 1.224646799e-16 (não é 0 exato)
sin(pi) == 0                 # FALSE
all.equal(sin(pi), 0)        # TRUE

# 3) Ajustando a tolerância manualmente (quando precisar ser mais/menos rígido)
all.equal(x, y, tolerance = 1e-12)  # ainda TRUE
all.equal(x, y, tolerance = 1e-20)  # agora acusa diferença

# 4) Estratégia base sem all.equal: comparar o |erro| com um limite
abs((sqrt(2))^2 - 2) < 1e-12 # TRUE (aceita "igualdade" numérica com folga)

```


2) Aritmética

Operadores básicos: `+ - * / ^` e, ainda, divisão inteira `%/%` e módulo `%%`.


```{r}
#| label: aritmetica
#| echo: true
14/6
14 %/% 6 # quociente inteiro
14 %% 6 # resto
2^3  # potência
```


- Precedência: `^` → `* / %/% %%` → `+ -`. **Use parênteses para deixar claro!**

3) Atribuição

O padrão recomendado é `<-`. `=` também atribui, mas use-o preferencialmente para argumentos de função. `->` é atribuição para a direita. `<<-` afeta o ambiente pai (use com parcimônia).


```{r}
#| label: atribuicao
#| echo: true
x <- 10
y = 5   # ok, mas prefira <- fora de chamadas de função
z <- x + y

z -> resultado  # atribuição para a direita (menos comum)
resultado

# Exemplo de <<- (evite, pode dificultar depuração)
contador <- local({
  n <- 0
  function() { n <<- n + 1; n }
})
contador(); contador(); contador()

```


::: callout-warning
**Boas práticas:** Evite `<<-` sempre que possível; prefira retornar valores e trabalhar com escopos explícitos.
:::

4) Vetores (atômicos)

Vetores são coleções unidimensionais do mesmo tipo: lógico, inteiro, double, caractere, complexo ou raw.

```{r}
#| label: vetores-basico
#| echo: true
v <- c(2, 4, 6, 8)
length(v); typeof(v)

seq(1, 5, by = 2)      # sequência
1:5                    # atalho
rep(3, times = 4)      # repetição
```

- *Coerção automática:* ao misturar tipos, `R` promove para um tipo comum.

```{r}
#| echo: true
c(1, TRUE, "a") # tudo vira character
```

::: callout-warning
Quando você faz `c(1, TRUE, "a")`, o `R` precisa escolher um tipo comum para todos os elementos. A regra de coerção (promoção de tipos) segue, a grosso modo:

`logical` ⟶ `integer` ⟶ `double` ⟶ `complex` ⟶ `character`
:::


- Indexação e filtragem:

```{r}
#| label: indexacao
#| echo: true
x <- c(10, 20, 30, 40, 50)
x[3]             # posição
x[-1]            # tudo, exceto o 1º
x[x > 25]        # filtragem lógica
which(x > 25)    # posições TRUE
names(x) <- letters[1:5]
x["c"]
```

4.1. Vetorização e reciclagem

A maioria das operações é vetorizada (aplica-se elemento a elemento). Quando os comprimentos diferem, `R` tenta reciclar o menor vetor.


```{r}
#| label: vetorizacao
#| echo: true
a <- 1:5
b <- 10
a + b   # soma escalar-vetor (b é reciclado)

a + c(1, 2) # reciclagem com aviso (5 não é múltiplo de 2)
```



4.2. Nomes × Objetos e copy-on-modify

```{r}
#| label: copy-on-modify
#| echo: true
x <- 1:3
y <- x
y[1] <- 99
x  # permanece 1 2 3
y  # 99 2 3
```

::: callout-warning
Exceção: ambientes e estruturas por referência (p.ex., R6) não seguem copy-on-modify.
:::

### Exercícios  {.unnumbered}

1. Crie um vetor com os números de `5` a `15` e calcule a média.

2. Use `seq()` para gerar `0, 0.5, 1,..., 5`.

3. Mostre com código a diferença entre `%/%` e `%%` usando 14 e 6.

4. Atribua `x <- 1:4` e some com o vetor `c(10, 20)`. O que acontece?

5. Verifique o tipo de `1`, `1L` e `1+0i`. Explique a diferença entre tipo (typeof) e classe (class).

6. Crie e armazene uma sequência de valores de `5 a −11`, progredindo em `passos de 0.3`.

7. Reescreva o objeto de (6) com a mesma sequência invertida.

8. Repita o vetor `c(-1, 3, -5, 7, -9)` duas vezes, com cada elemento repetido 10 vezes.
Apresente os dados ordenados do maior para o menor.

9. Crie e armazene um vetor contendo, em qualquer ordem:

a) inteiros de `6` a `12` (inclusive);

b) `5.3` repetido 3 vezes;

c) o número `−3`;

d) Uma sequência de nove valores começando em `102` e terminando no número que é o comprimento total do vetor criado em (8).

10. Confirme que o comprimento do vetor criado em (9) é 20.

<!-- ## Estrutura Lógicas {.unnumbered} -->

<!-- ## Estruturas de Controle {.unnumbered} -->

<!-- ## Funções {.unnumbered} -->

<!-- ## Distribuições de Probabilidade {.unnumbered} -->

## Matrizes {.unnumbered}

A matriz é uma construção matemática importante e é essencial para muitos métodos estatísticos. Normalmente descreve-se uma matriz $A$ como uma matriz $m \times n$; isto é, $A$ terá exatamente $m$ linhas e $n$ colunas. Isso significa que $A$ terá um total de $mn$ entradas, com cada entrada a $i, j$ ocupando uma posição única dada por sua linha específica $(i = 1, 2,\dots, m)$ e coluna $(j = 1, 2,\dots, n)$.


Para criar uma matriz no `R`, use o comando, apropriadamente chamado, `matrix`, fornecendo as entradas da matriz ao argumento `data` como um vetor:

```{r}
A <- matrix(
     data = c(-3, 2, 893, 0.17),
     nrow = 2, #linha
     ncol = 2  #colunas
     )


A
```


É importante estar ciente de como o `R` preenche a matriz usando as entradas de `data`. Observando o exemplo anterior, você pode ver que a matriz $A$ foi preenchida coluna por coluna ao ler as entradas de dados da esquerda para a direita. Você pode controlar como o `R` preenche os dados usando o argumento `byrow`, como mostrado nos exemplos a seguir:


```{r}
matrix(data = c(1,2,3,4,5,6), nrow = 2, ncol = 3, byrow = FALSE)
```

Qual a diferença na construção da matriz ao usar `byrow = TRUE`?


Também é possível construir matrizes usando os comandos `cbind` e `rbind`. Veja os exemplos abaixo:

```{r}
cbind(c(1,4), c(2,5), c(3,6))
rbind(1:3,4:6)
```

Para saber a dimensão, número de linhas e colunas de uma matriz você pode usar os seguintes comandos:

```{r}
dim(A); nrow(A); ncol(A)
```

Considere a seguinte matriz:

```{r}
A <- matrix(c(0.3, 4.5, 55.3, 91, 0.1, 105.5, -4.2, 8.2, 27.9), nrow = 3, ncol = 3)

A
```


Para dizer ao `R` para “olhar para a terceira linha de $A$ e me dar o elemento da
segunda coluna”, você executa o seguinte:


```{r}
A[3, 2]
```

Como esperado, você recebe o elemento na posição $[3,2]$.

Você também pode identificar os valores ao longo da diagonal de uma matriz quadrada (isto é, uma matriz com igual número de linhas e colunas) usando o comando `diag`.

```{r}
diag(A)
```



### Exercícios {.unnumbered}

**(a)** Construa e armazene uma matriz $4 \times 2$ preenchida **por linhas** com os valores:  4.3, 3.1, 8.2, 8.2, 3.2, 0.9, 1.6 e 6.5 (nessa ordem).

**(b)** Confirme que as dimensões da matriz do item (a) são $3 \times 2$ se você remover qualquer uma das linhas.

**(c)** Sobrescreva a **segunda coluna** da matriz do item (a) com essa mesma coluna **ordenada do menor para o maior**.

**(d)** O que o `R` retorna se você excluir a **quarta linha** e a **primeira coluna** do item (c)? Use `matrix` para garantir que o resultado seja uma **matriz de uma única coluna**, e não um vetor.

**(e)** Armazene os **quatro elementos inferiores** do item (c) como uma nova matriz $2 \times 2$.

**(f)** Sobrescreva, **nesta ordem**, os elementos do item (c) nas posições $(4, 2), (1, 2), (4, 1)$ e $(1, 1)$ com $-\tfrac{1}{2}$ dos dois valores na **diagonal do item (e)**.


## Operações com matrizes {.unnumbered}

Em `R`, a transposta de uma matriz se obtém com `t()`, ela troca linhas por colunas.

```{r}
A <- rbind(c(2,5,2),c(6,1,4))

t(A)
```

Você pode criar uma matriz identidade de qualquer dimensão usando a função `matrix`, mas há uma forma mais rápida usando `diag`. Antes, usei `diag` em uma matriz existente para extrair ou sobrescrever seus elementos da diagonal. Você também pode usá-la assim:

```{r}
I4 <- diag(4) # 4x4
I4


I5 <- diag(1, nrow = 5, ncol = 5) #forma explicita
I5
```

O `R` realizará essa multiplicação de maneira elemento a elemento, como você poderia esperar. A multiplicação escalar de uma matriz é realizada usando o operador aritmético padrão `*`.

```{r}
A <- rbind(c(2,5,2) , c(6,1,4))
a <- 2

a*A
```

Você pode somar ou subtrair quaisquer duas matrizes de mesmo tamanho usando os símbolos padrão `+` e `-`.

```{r}
A <- cbind(c(2,5,2), c(6,1,4))

A

B <-  cbind(c(-2,3,6), c(8.1,8.2,-9.8))

B

A - B

A + B 
```

Ao contrário da adição, subtração e multiplicação escalar, a multiplicação de matrizes não é um cálculo elemento a elemento, e o operador padrão `*` não pode ser usado. Em vez disso, você deve usar o operador de produto matricial do `R`, escrito com símbolos de porcentagem como `%*%`. Antes de tentar esse operador, vamos primeiro armazenar as duas matrizes de exemplo e verificar se o número de colunas na primeira matriz corresponde ao número de linhas na segunda matriz usando `dim`.


```{r}
A <- rbind(c(2,5,2), c(6,1,4))

dim(A)

B <-  cbind(c(3,-1,1), c(-3,1,5))

dim(B)
```

Isso confirma que as duas matrizes são compatíveis para a multiplicação, então você pode prosseguir.


```{r}
A%*%B
```

Você pode mostrar que a multiplicação de matrizes é **não comutativa** usando as mesmas duas matrizes. Inverter a ordem da multiplicação produz um resultado completamente diferente.

```{r}
B%*%A
```


Matrizes que não são invertíveis são chamadas de singulares. Inverter uma matriz é frequentemente necessário ao resolver sistemas de equações e tem implicações práticas importantes. Há vários métodos para inversão, e o custo computacional cresce muito à medida que o tamanho da matriz aumenta. Não entraremos em detalhes aqui; para discussões formais, veja Golub e Van Loan (1989). Por ora, veja a função `solve` do `R` como uma opção para inverter matrizes.

```{r}
A <- matrix(data = c(3, 4, 1, 2), nrow = 2, ncol = 2)

A

solve(A)
```

Você também pode verificar que o produto dessas duas matrizes (usando as regras de multiplicação de matrizes) resulta na matriz identidade $2 \times 2$

```{r}
A %*% solve(A)
```


### Exercícios {.unnumbered}

**(a)** Calcule

$$
\frac{2}{7}\left(
\begin{bmatrix}1 & 2\\2 & 4 \\ 7 & 6\end{bmatrix}
-
\begin{bmatrix}10 & 20\\30 & 40 \\ 50 & 60\end{bmatrix}
\right).
$$

**(b)** Armazene as duas matrizes abaixo:

$$
A=\begin{bmatrix}1\\2\\7\end{bmatrix},
\quad
B=\begin{bmatrix}3\\4\\8\end{bmatrix}.
$$

Quais das multiplicações a seguir são possíveis? Para as que forem, calcule o resultado.

i. $A \cdot B$;

ii. $A^{\top} \cdot B$;

iii. $B^{\top} \cdot (A \cdot A^{\top})$;

iv. $(A \cdot A^{\top}) \cdot B^{\top}$;

v. $\big[(B \cdot B^{\top}) + (A \cdot A^{\top}) - 100\,I_{3}\big]^{-1}$.


**(c)** Para

$$
A = \begin{bmatrix}
2&0&0&0\\
0&3&0&0\\
0&0&5&0\\
0&0&0&-1
\end{bmatrix},
$$

confirme que $A^{-1}\cdot A - I_{4}$ fornece uma matriz $4\times 4$ de zeros.








