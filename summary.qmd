# N√∫meros Uniformes

As simula√ß√µes, de modo geral, requerem uma base inicial formada por n√∫meros aleat√≥rios. Diz-se que uma sequ√™ncia $R_1, R_2, \ldots$ √© composta por n√∫meros aleat√≥rios quando cada termo segue a distribui√ß√£o uniforme $U(0,1)$ e $R_i$ √© independente de $R_j$ para todo $i \neq j$. Embora alguns autores utilizem o termo ‚Äún√∫meros aleat√≥rios‚Äù para se referir a vari√°veis amostradas de qualquer distribui√ß√£o, aqui ele ser√° usado exclusivamente para vari√°veis com distribui√ß√£o $U(0,1)$.

## Gera√ß√£o de sequ√™ncias $U(0,1)$

Uma abordagem √© utilizar dispositivos f√≠sicos aleatorizadores, como m√°quinas que sorteiam n√∫meros de loteria, roletas ou circuitos eletr√¥nicos que produzem ‚Äúru√≠do aleat√≥rio‚Äù. Contudo, tais dispositivos apresentam desvantagens:

1.  **Baixa velocidade** e dificuldade de integra√ß√£o direta com computadores.
2.  **Necessidade de reprodutibilidade** da sequ√™ncia. Por exemplo, para verifica√ß√£o de c√≥digo ou compara√ß√£o de pol√≠ticas em um modelo de simula√ß√£o, usando a mesma sequ√™ncia para reduzir a vari√¢ncia da diferen√ßa entre resultados.

Uma forma simples de obter reprodutibilidade √© armazenar a sequ√™ncia em um dispositivo de mem√≥ria (HD, CD-ROM, livro). De fato, a RAND Corporation publicou *A Million Random Digits with 100 000 Random Normal Deviates* (1955). Entretanto, acessar armazenamento externo milhares ou milh√µes de vezes torna a simula√ß√£o lenta.

Assim, a abordagem preferida √© **gerar n√∫meros pseudoaleat√≥rios em tempo de execu√ß√£o**, via recorr√™ncias determin√≠sticas sobre inteiros. Isso permite:

-   Gera√ß√£o r√°pida;
-   Elimina√ß√£o do problema de armazenamento;
-   Reprodutibilidade controlada.

Entretanto, a escolha inadequada da recorr√™ncia pode gerar sequ√™ncias com baixa qualidade estat√≠stica. Um dos m√©todos mais antigos e influentes para isso √© o **Gerador Congruencial Linear (GCL)**.

### Gerador Congruencial Linear {.unnumbered}

O GCL produz uma sequ√™ncia de inteiros $x_0, x_1, x_2, \dots$ segundo a regra:


$$x_n = (a \, x_{n-1} + c) \;\; \text{mod} \;\; m$$

em que, $m > 0$ √© o **m√≥dulo**, $a$ √© o **multiplicador**, $c$ √© o **incremento** e  
$x_0$ √© a **semente** (*seed*), escolhida pelo usu√°rio.  

O resultado final √© obtido normalizando os valores:


$$u_n = \frac{x_n}{m}, \quad \text{com } u_n \in (0, 1).$$


::: callout-note
## Tipos

- **Multiplicativo:** $c = 0$.  
- **Misto:** $c \neq 0$. 
:::

### Por que o LCG funciona? {.unnumbered}

1. **Simplicidade:** apenas uma multiplica√ß√£o, uma soma e uma opera√ß√£o de m√≥dulo.  
2. **Velocidade:** pode ser implementado de forma extremamente eficiente.  
3. **Controle:** dependendo da escolha de $a, c, m$, √© poss√≠vel obter um per√≠odo longo, ou seja, muitos n√∫meros gerados antes de a sequ√™ncia se repetir.  


### Crit√©rios para bons par√¢metros {.unnumbered}

- O m√≥dulo $m$ deve ser **grande**, de prefer√™ncia pr√≥ximo da capacidade da m√°quina.  
- Para LCG multiplicativo, se $m$ for primo, existe a possibilidade de alcan√ßar per√≠odo m√°ximo $m-1$.  
- Valores hist√≥ricos:  
  - **Park‚ÄìMiller (1988):** $m = 2^{31} - 1$, $a = 16807$, $c = 0$.  
  - **Numerical Recipes (1992):** $m = 2^{32}$, $a = 1664525$, $c = 1013904223$.  


#### Exemplos {.unnumbered}

```{python}
#| label: lcg-python
#| echo: true
# Gerador Congruencial Linear em Python

def lcg(seed, a, c, m, n=10):
    """Gera n n√∫meros pseudoaleat√≥rios normalizados em (0,1)."""
    x = seed
    seq = []
    for _ in range(n):
        x = (a * x + c) % m
        seq.append(x / m)
    return seq

# Exemplo: Park‚ÄìMiller (multiplicativo)
m = 2**31 - 1
a = 16807
c = 0
seed = 12345

lcg(seed, a, c, m, n=10)
```


```{R}
#| label: lcg-r
#| echo: true
# Gerador Congruencial Linear em R

lcg <- function(seed, a, c, m, n=10) {
  x <- seed
  seq <- numeric(n)
  for (i in 1:n) {
    x <- (a * x + c) %% m
    seq[i] <- x / m
  }
  seq
}

# Exemplo: Park‚ÄìMiller
m <- 2^31 - 1
a <- 16807
c <- 0
seed <- 12345

lcg(seed, a, c, m, n=10)

```


### Visualiza√ß√£o {.unnumbered}

Uma forma simples de verificar se um gerador se comporta bem √© observar os valores em um gr√°fico de dispers√£o $(u_{n}, u_{n+1}).$

- Um bom gerador mostra pontos espalhados de forma quase aleat√≥ria.

- Um gerador ruim forma padr√µes vis√≠veis (linhas ou grades).

### Limita√ß√µes {.unnumbered}

Apesar de sua import√¢ncia hist√≥rica, os LCGs apresentam limita√ß√µes:

- O per√≠odo, mesmo que longo, √© finito.

- Podem apresentar correla√ß√µes indesejadas em dimens√µes mais altas.

- N√£o s√£o recomendados para aplica√ß√µes de alta seguran√ßa (como criptografia).

Hoje, geradores como o Mersenne Twister substitu√≠ram o LCG em muitas linguagens (por exemplo, √© o padr√£o no `R` e no `NumPy`). Ainda assim, o LCG √© fundamental para entender os princ√≠pios da gera√ß√£o de n√∫meros pseudoaleat√≥rios.


#### Exerc√≠cios {.unnumbered}

1. Implemente um LCG (multiplicativo ou misto) em `Python` ou `R`.

2. Gere 1000 n√∫meros pseudoaleat√≥rios e fa√ßa:

- Um histograma para verificar se a distribui√ß√£o se parece com a uniforme $(0, 1)$.

- Um gr√°fico de dispers√£o de pares consecutivos $(u_{n}, u_{n+1})$.

3. Compare o comportamento quando:

- Usa os par√¢metros cl√°ssicos de Park‚ÄìMiller $(m = 2^{31} - 1, a = 16807, c = 0)$.

- Usa par√¢metros pequenos, por exemplo $m = 17, a = 5, c = 1$.

Pergunta para reflex√£o: O que acontece com a qualidade dos n√∫meros gerados quando usamos par√¢metros pequenos?


::: callout-note
## Park‚ÄìMiller hoje: ainda vale a pena?

O gerador congruencial linear cl√°ssico de **Park‚ÄìMiller** foi proposto em 1988, com par√¢metros:


$$m = 2^{31} - 1 \approx 2,147,483,647, \quad a = 16807, \quad c = 0.$$


Na √©poca, esses valores eram ideais para computadores de **32 bits**, embora a implementa√ß√£o precisasse de alguns cuidados para evitar **overflow**.

Nos computadores modernos de **64 bits**, esse problema desaparece: o produto \(a \times x\) cabe confortavelmente nos registradores, e a implementa√ß√£o √© direta e eficiente.

**Vantagens atuais:**

- Simples e r√°pido.  

- F√°cil de implementar em qualquer linguagem.  

- Per√≠odo m√°ximo de mais de **2 bilh√µes** de n√∫meros.  

**Limita√ß√µes:**

- Hoje, esse per√≠odo pode ser considerado curto para simula√ß√µes muito extensas.  

- Geradores modernos, como o **Mersenne Twister** (per√≠odo $2^{19937}-1$) ou a fam√≠lia **PCG (Gerador Congruencial Permutado)**, oferecem propriedades estat√≠sticas superiores.


üìå **Em resumo:** O Park‚ÄìMiller ainda √© excelente para fins did√°ticos e pequenas simula√ß√µes, mas para aplica√ß√µes cient√≠ficas de grande escala recomenda-se usar geradores mais robustos.
:::


## Uso de N√∫meros Aleat√≥rios na Avalia√ß√£o de Integrais 

Uma das primeiras aplica√ß√µes do uso de n√∫meros aleat√≥rios foi na resolu√ß√£o de integrais. Considere uma fun√ß√£o $g(x)$ e suponha que desejamos calcular uma integral de interesse.

$$\theta = \int\limits_{0}^{1}g(x) dx.$$

Para calcular o valor da integral, observe que, se $U$ √© uma vari√°vel aleat√≥ria com distribui√ß√£o uniforme no intervalo $(0, 1)$, , ent√£o podemos reescrever a integral da seguinte forma:

$$\theta = E[g(U)].$$ Se $U_1, U_2, \dots,  U_n$ s√£o vari√°veis aleat√≥rias independentes e uniformes em $(0, 1)$, ent√£o as vari√°veis $g(U_1), g(U_2), \dots,  g(U_n)$ s√£o indepedentes e identicamente distribu√≠das, todas com esperan√ßa igual $\theta$ (o valor da integral). Assim, pelo **Teorema da Lei Forte dos Grandes N√∫meros**, temos que, com probabilidade 1,

$$\frac{1}{n}\sum\limits_{i=1}^{n}g(U_i) \to \theta \quad \text{quando} \quad n \to \infty.$$

Assim, podemos aproximar o valor da integral gerando um grande n√∫mero de pontos aleat√≥rios $u_i$ no intervalo $(0, 1)$ e tomando como estimativa a m√©dia dos valores $g(u_i)$. Esse procedimento de aproxima√ß√£o de integrais √© conhecido como m√©todo de **Monte Carlo**.

Se quisermos calcular uma integral mais geral, podemos aplicar a mesma ideia: transformar o problema em uma esperan√ßa matem√°tica e, em seguida, aproxim√°-la por meio de m√©dias amostrais obtidas a partir de n√∫meros aleat√≥rios. Considere:

$$\theta = \int\limits_{a}^{b}g(x) dx.$$

Se quisermos calcular a integral em um intervalo gen√©rico $(a, b)$, fazemos a substitui√ß√£o

$$u = \frac{x - a}{b-a}, \quad du = \frac{dx}{b-a},$$

o que nos permite reescrev√™-la como

$$\theta = \int\limits_{a}^{b}g(x) dx = (b-a)\int\limits_{0}^{1}g(a + (b-a)u) du.$$

Definindo

$$h(u) = (b-a)g(a + (b-a)u),$$

temos

$$\theta = \int\limits_{0}^{1}h(u) du.$$

Assim, podemos aproximar $\theta$ gerando n√∫meros aleat√≥rios $u_1, u_2, \dots, u_n \sim U(0, 1)$ e tomando como estimativa a m√©dia

$$\theta \approx \frac{1}{n}\sum\limits_{i=1}^{n}h(u_i).$$ Agora, se nosso objetivo √© calcular a integral:

$$\theta = \int\limits_{0}^{\infty}g(x) dx.$$

Fazendo a mudan√ßa de vari√°vel

$$u = \frac{1}{x+1}, \quad du = \frac{-dx}{(x+1)^2} = -u^2 dx.$$

Logo,

$$dx = -\frac{du}{u^2},$$

e a integral resultante √©

$$\theta = \int\limits_{0}^{1}h(u) du,$$

com

$$h(u) = \frac{g\left(\frac{1}{u} - 1\right)}{u^2}.$$

A utilidade de empregar n√∫meros aleat√≥rios para aproximar integrais torna-se ainda mais evidente no caso de integrais multidimensionais. Suponha que $g$ seja uma fun√ß√£o com argumento $n$-dimensional e que estejamos interessados em calcular:

$$\theta = \int\limits_{0}^{1}\int\limits_{0}^{1}\dots\int\limits_{0}^{1} g(x_1, x_2, \dots, x_n)dx_1 dx_2 \dots dx_n.$$

Observe que $\theta$ pode ser expresso como o seguinte valor esperado:

$$\theta = E[g(U_1, U_2, \dots, U_n)],$$

em que $U_1, U_2, \dots, U_n$ s√£o vari√°veis aleat√≥ria independentes uniformente distribu√≠das no intervalo $(0, 1)$. Assim, se gerarmos $k$ conjuntos independentes, cada um formado por $n$ vari√°veis aleat√≥rias independentes com distribui√ß√£o uniforme em $(0, 1)$, ent√£o as vari√°veis

$$g(U_{i1}, U_{i2}, \dots, U_{in}), \quad i = 1, 2, \dots, k,$$ ser√£o independentes e identicamente distribu√≠das, todas com esperan√ßa igual a $\theta$ (o valor da integral). Portanto, podemos aproximar $\theta$ por meio da m√©dia amostral:

$$\theta \approx \frac{1}{k}\sum\limits_{i=1}^{k}g(U_{i1}, U_{i2}, \dots, U_{in}).$$
