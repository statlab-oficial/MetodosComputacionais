# Números Uniformes

As simulações, de modo geral, requerem uma base inicial formada por números aleatórios. Diz-se que uma sequência $R_1, R_2, \ldots$ é composta por números aleatórios quando cada termo segue a distribuição uniforme $U(0,1)$ e $R_i$ é independente de $R_j$ para todo $i \neq j$. Embora alguns autores utilizem o termo “números aleatórios” para se referir a variáveis amostradas de qualquer distribuição, aqui ele será usado exclusivamente para variáveis com distribuição $U(0,1)$.

## Geração de sequências $U(0,1)$

Uma abordagem é utilizar dispositivos físicos aleatorizadores, como máquinas que sorteiam números de loteria, roletas ou circuitos eletrônicos que produzem “ruído aleatório”. Contudo, tais dispositivos apresentam desvantagens:

1. **Baixa velocidade** e dificuldade de integração direta com computadores.
2. **Necessidade de reprodutibilidade** da sequência. Por exemplo, para verificação de código ou comparação de políticas em um modelo de simulação, usando a mesma sequência para reduzir a variância da diferença entre resultados.

Uma forma simples de obter reprodutibilidade é armazenar a sequência em um dispositivo de memória (HD, CD-ROM, livro). De fato, a RAND Corporation publicou *A Million Random Digits with 100 000 Random Normal Deviates* (1955). Entretanto, acessar armazenamento externo milhares ou milhões de vezes torna a simulação lenta.

Assim, a abordagem preferida é **gerar números pseudoaleatórios em tempo de execução**, via recorrências determinísticas sobre inteiros. Isso permite:

- Geração rápida;
- Eliminação do problema de armazenamento;
- Reprodutibilidade controlada.

Entretanto, a escolha inadequada da recorrência pode gerar sequências com baixa qualidade estatística.


## Geradores Congruenciais Lineares

Um **Gerador Congruencial Linear (LGC)** produz uma sequência de inteiros não negativos $X_i$, $i = 1, 2, \ldots$, por meio da relação de recorrência:

$$X_i = (a X_{i-1} + c) \bmod m, \quad i = 1, 2, \ldots,$$
em que $a > 0$ é o multiplicador, $X_0 \ge 0$ é a *semente* (*seed*), $c \ge 0$ é o incremento e $m > 0$ é o módulo.

Os valores  $a, c, X_0$ estão no intervalo $[0, m-1]$. O número pseudoaleatório $R_i$ é obtido por:


$$R_i = \frac{X_i}{m}, \quad R_i \in (0,1).$$

Se $m$ for suficientemente grande, os valores discretos $0/m, 1/m, \ldots, (m-1)/m$ são tão próximos que $R_i$ pode ser tratado como variável contínua.


### Exemplo

Seja o gerador:

$$X_i = (9 X_{i-1} + 3) \bmod 24, \quad i \geq 1.$$

Escolhendo $X_0 = 3$:


$$X_1 = (9 \times 3 + 3) \bmod 24 = 14$$

$$X_2 = (9 \times 14 + 3) \bmod 24 = 1$$

e assim por diante.

A sequência $R_i = X_i / 16$ gerada terá período $\ell = 16$.

### Implementação em R

```{r}
# Função LCG genérica
lcg <- function(a, c, m, seed, n) {
  x <- numeric(n)
  x[1] <- seed
  for (i in 2:n) {
    x[i] <- (a * x[i-1] + c) %% m
  }
  r <- x / m
  return(list(X = x, R = r))
}

# Exemplo com a = 9, c = 3, m = 24, seed = 3
resultado <- lcg(a = 9, c = 3, m = 24, seed = 3, n = 20)
resultado$X
resultado$R
```

## Geradores Congruenciais Lineares Mistos

Nos LCGs **mistos** temos $c>0$. Uma escolha prática é $m = 2^b$, onde $b$ é o número de bits utilizável para inteiros positivos na arquitetura/linguagem. Em muitos ambientes, inteiros usam 32 bits (um para o sinal), implicando $b=31$ e intervalo $[-2^{31}, 2^{31}-1]$.

Quando $m=2^b$, obtemos **período completo** ($\ell=m$) se:

1) $c$ é **ímpar** (garante $\gcd(c,m)=1$);  
2) $a-1$ é múltiplo de todos os fatores primos de $m$ e também de 4 (como $m$ é potência de 2).

Essa é a razão de geradores simples com $m=2^b$, $c$ ímpar e $a \equiv 1 \pmod 4$ atingirem $\ell=m$.

### Questão de estouro e aritmética modular

Em linguagens com inteiros limitados, calcular $aX_{i-1}+c$ pode **transbordar**. Soluções comuns:

- usar precisão estendida (64 bits) ou bibliotecas de inteiros grandes;
- empregar **truques de aritmética modular** (como o método de Schrage) para evitar overflow;
- trabalhar com módulo $m=2^b$ e aproveitar o “wrap” de bits.

A seguir, implementamos LCG misto com $m=2^{31}$, $a=906185749$, $c=1$. Parâmetros com boas propriedades estatísticas relatadas na literatura.

### Implementação em R (com segurança de overflow)

Para garantir a correção do módulo com inteiros grandes, usaremos `bit64` (inteiros de 64 bits) e normalizaremos para $(0,1)$.

```{r}
#| label: lcg-misto
#| message: false
#| warning: false
#if (!requireNamespace("bit64", quietly = TRUE)) {
#  install.packages("bit64")
#}

library(bit64)

lcg_misto <- function(n, seed = 3456L,
                      a = 906185749L,
                      c = 1L,
                      m = bit64::as.integer64(2)^31) {
  # Trabalha em integer64 para evitar perda de precisão
  x <- bit64::as.integer64(seed)
  outX <- bit64::integer64(n)
  outR <- numeric(n)
  outX[1] <- x
  outR[1] <- as.double(x) / as.double(m)
  for (i in 2:n) {
    x <- (bit64::as.integer64(a) * x + bit64::as.integer64(c)) %% m
    outX[i] <- x
    outR[i] <- as.double(x) / as.double(m)
  }
  list(X = outX, R = outR)
}

# Exemplo: primeiros 5 números com seed = 3456
set.seed(NULL)
g1 <- lcg_misto(n = 5, seed = 3456L)
g1$X
g1$R
```

## Geradores Congruenciais Lineares Multiplicativos

No caso **multiplicativo**, temos $c = 0$, e a recorrência fica:

$$
X_i = (a X_{i-1}) \bmod m
$$

### Características e restrições

- Se $X_i = 0$ em algum passo, toda a sequência futura será zero — portanto $X_0 \neq 0$.
- Se $a = 1$, a sequência é constante — também deve ser evitado.
- O **período máximo** possível é $m - 1$, e ele só é atingido quando:
  1. $m$ é primo;
  2. $a$ é uma **raiz primitiva** módulo $m$.

### Definição de raiz primitiva

Um número $a$ é raiz primitiva módulo $m$ se seus poderes geram todos os inteiros não nulos módulo $m$.  
Matematicamente, $a$ satisfaz:

$$
m \nmid a^{(m-1)/q} - 1, \quad \forall q \text{ primo que divide } m-1
$$

Esse tipo de gerador é chamado **Gerador de Módulo Primo e Período Máximo**.

---

### Exemplo de implementação em R

A seguir, implementamos um gerador multiplicativo com módulo primo $m = 2^{31} - 1$ (primo de Mersenne) e multiplicador $a = 630360016$, conhecido por apresentar boas propriedades estatísticas.

```{r}
#| label: lcg-multiplicativo-gmp
#| message: false
#| warning: false
if (!requireNamespace("gmp", quietly = TRUE)) {
  install.packages("gmp")
}
library(gmp)

lcg_mult_primo <- function(n, seed, a = 630360016, m = 2147483647) {
  A <- as.bigz(a); M <- as.bigz(m)
  x <- as.bigz(seed)
  X <- integer(n); R <- numeric(n)
  for (i in seq_len(n)) {
    X[i] <- as.integer(x)    
    R[i] <- as.numeric(x) / m    
    x <- (A * x) %% M            
  }
  list(X = X, R = R)
}

# Exemplo: gerar 10 valores
g2 <- lcg_mult_primo(n = 10, seed = 12345L)
g2$X
g2$R
```
