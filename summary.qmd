# N√∫meros Uniformes

As simula√ß√µes, de modo geral, requerem uma base inicial formada por n√∫meros aleat√≥rios. Diz-se que uma sequ√™ncia $R_1, R_2, \ldots$ √© composta por n√∫meros aleat√≥rios quando cada termo segue a distribui√ß√£o uniforme $U(0,1)$ e $R_i$ √© independente de $R_j$ para todo $i \neq j$. Embora alguns autores utilizem o termo ‚Äún√∫meros aleat√≥rios‚Äù para se referir a vari√°veis amostradas de qualquer distribui√ß√£o, aqui ele ser√° usado exclusivamente para vari√°veis com distribui√ß√£o $U(0,1)$.

## Gera√ß√£o de sequ√™ncias $U(0,1)$

Uma abordagem √© utilizar dispositivos f√≠sicos aleatorizadores, como m√°quinas que sorteiam n√∫meros de loteria, roletas ou circuitos eletr√¥nicos que produzem ‚Äúru√≠do aleat√≥rio‚Äù. Contudo, tais dispositivos apresentam desvantagens:

1.  **Baixa velocidade** e dificuldade de integra√ß√£o direta com computadores.
2.  **Necessidade de reprodutibilidade** da sequ√™ncia. Por exemplo, para verifica√ß√£o de c√≥digo ou compara√ß√£o de pol√≠ticas em um modelo de simula√ß√£o, usando a mesma sequ√™ncia para reduzir a vari√¢ncia da diferen√ßa entre resultados.

Uma forma simples de obter reprodutibilidade √© armazenar a sequ√™ncia em um dispositivo de mem√≥ria (HD, CD-ROM, livro). De fato, a RAND Corporation publicou *A Million Random Digits with 100 000 Random Normal Deviates* (1955). Entretanto, acessar armazenamento externo milhares ou milh√µes de vezes torna a simula√ß√£o lenta.

::: callout-note

- Tamb√©m existem fontes para n√∫meros aleat√≥rios reais na Internet. 

- O [www.random.org](https://www.random.org/) oferece n√∫meros
aleat√≥rios verdadeiros para qualquer pessoa na internet. A aleatoriedade vem do ru√≠do atmosf√©rico, que para muitos prop√≥sitos √© melhor do que os algoritmos de n√∫meros pseudoaleat√≥rios normalmente usados em programas de computador. As pessoas usam os n√∫meros para operar loterias, sorteios e apostas, e para seus jogos e sites de apostas.

- Em [www.randomnumbers.info](https://www.randomnumbers.info/) √© oferecida a possibilidade de baixar n√∫meros aleat√≥rios gerados usando um gerador qu√¢ntico de n√∫meros aleat√≥rios sob demanda.
:::

Assim, a abordagem preferida √© **gerar n√∫meros pseudoaleat√≥rios em tempo de execu√ß√£o**, via recorr√™ncias determin√≠sticas sobre inteiros. Isso permite:

-   Gera√ß√£o r√°pida;
-   Elimina√ß√£o do problema de armazenamento;
-   Reprodutibilidade controlada.

Entretanto, a escolha inadequada da recorr√™ncia pode gerar sequ√™ncias com baixa qualidade estat√≠stica. Um dos m√©todos mais antigos e influentes para isso √© o **Gerador Congruencial Linear (GCL)**.

### Gerador Congruencial Linear {.unnumbered}

O GCL produz uma sequ√™ncia de inteiros $x_0, x_1, x_2, \dots$ segundo a regra:

$$x_n = (a \, x_{n-1} + c) \;\; \text{mod} \;\; m$$

em que, $m > 0$ √© o **m√≥dulo**, $a$ √© o **multiplicador**, $c$ √© o **incremento** e\
$x_0$ √© a **semente** (*seed*), escolhida pelo usu√°rio.

O resultado final √© obtido normalizando os valores:

$$u_n = \frac{x_n}{m}, \quad \text{com } u_n \in (0, 1).$$

::: callout-note
## Tipos

-   **Multiplicativo:** $c = 0$.\
-   **Misto:** $c \neq 0$.
:::

### Por que o GCL funciona? {.unnumbered}

1.  **Simplicidade:** apenas uma multiplica√ß√£o, uma soma e uma opera√ß√£o de m√≥dulo.\
2.  **Velocidade:** pode ser implementado de forma extremamente eficiente.\
3.  **Controle:** dependendo da escolha de $a, c, m$, √© poss√≠vel obter um per√≠odo longo, ou seja, muitos n√∫meros gerados antes de a sequ√™ncia se repetir.

### Crit√©rios para bons par√¢metros {.unnumbered}

-   O m√≥dulo $m$ deve ser **grande**, de prefer√™ncia pr√≥ximo da capacidade da m√°quina.\
-   Para GCL multiplicativo, se $m$ for primo, existe a possibilidade de alcan√ßar per√≠odo m√°ximo $m-1$.\
-   Valores hist√≥ricos:
    -   **Park‚ÄìMiller (1988):** $m = 2^{31} - 1$, $a = 16807$, $c = 0$.\
    -   **Numerical Recipes (1992):** $m = 2^{32}$, $a = 1664525$, $c = 1013904223$.

#### Exemplos {.unnumbered}

```{python}
#| label: glc-python
#| echo: true
# Gerador Congruencial Linear em Python

def gcl(seed, a, c, m, n = 10):
    "Gera n n√∫meros pseudoaleat√≥rios normalizados em (0,1)."
    x = seed
    seq = []
    for _ in range(n):
        x = (a * x + c) % m
        seq.append(x / m)
    return seq

# Exemplo: Park‚ÄìMiller (multiplicativo)
m = 2**31 - 1
a = 16807
c = 0
seed = 12345

gcl(seed, a, c, m, n=10)
```

```{R}
#| label: glc-r
#| echo: true
# Gerador Congruencial Linear em R

gcl <- function(seed, a, c, m, n=10) {
  x <- seed
  seq <- numeric(n)
  for (i in 1:n) {
    x <- (a * x + c) %% m
    seq[i] <- x / m
  }
  seq
}

# Exemplo: Park‚ÄìMiller
m <- 2^31 - 1
a <- 16807
c <- 0
seed <- 12345

gcl(seed, a, c, m, n=10)

```

### Visualiza√ß√£o {.unnumbered}

Uma forma simples de verificar se um gerador se comporta bem √© observar os valores em um gr√°fico de dispers√£o $(u_{n}, u_{n+1}).$

-   Um bom gerador mostra pontos espalhados de forma quase aleat√≥ria.

-   Um gerador ruim forma padr√µes vis√≠veis (linhas ou grades).

### Limita√ß√µes {.unnumbered}

Apesar de sua import√¢ncia hist√≥rica, os GCLs apresentam limita√ß√µes:

-   O per√≠odo, mesmo que longo, √© finito.

-   Podem apresentar correla√ß√µes indesejadas em dimens√µes mais altas.

-   N√£o s√£o recomendados para aplica√ß√µes de alta seguran√ßa (como criptografia).

Hoje, geradores como o **Mersenne Twister** substitu√≠ram o GCL em muitas linguagens (por exemplo, √© o padr√£o no `R` e no `NumPy`). Ainda assim, o GCL √© fundamental para entender os princ√≠pios da gera√ß√£o de n√∫meros pseudoaleat√≥rios.

#### Exerc√≠cios {.unnumbered}

1.  Implemente um GCL (multiplicativo ou misto) em `Python` ou `R`.

2.  Gere 1000 n√∫meros pseudoaleat√≥rios e fa√ßa:

-   Um histograma para verificar se a distribui√ß√£o se parece com a uniforme $(0, 1)$.

-   Um gr√°fico de dispers√£o de pares consecutivos $(u_{n}, u_{n+1})$.

3.  Compare o comportamento quando:

-   Usa os par√¢metros cl√°ssicos de Park‚ÄìMiller $(m = 2^{31} - 1, a = 16807, c = 0)$.

-   Usa par√¢metros pequenos, por exemplo $m = 17, a = 5, c = 1$.

**Pergunta para reflex√£o:** O que acontece com a qualidade dos n√∫meros gerados quando usamos par√¢metros pequenos?


::: callout-note
## Park‚ÄìMiller hoje: ainda vale a pena?

O gerador congruencial linear cl√°ssico de **Park‚ÄìMiller** foi proposto em 1988, com par√¢metros:

$$m = 2^{31} - 1 \approx 2,147,483,647, \quad a = 16807, \quad c = 0.$$

Na √©poca, esses valores eram ideais para computadores de **32 bits**, embora a implementa√ß√£o precisasse de alguns cuidados para evitar **overflow**.

Nos computadores modernos de **64 bits**, esse problema desaparece: o produto $a \times x$ cabe confortavelmente nos registradores, e a implementa√ß√£o √© direta e eficiente.

**Vantagens atuais:**

-   Simples e r√°pido.

-   F√°cil de implementar em qualquer linguagem.

-   Per√≠odo m√°ximo de mais de **2 bilh√µes** de n√∫meros.

**Limita√ß√µes:**

-   Hoje, esse per√≠odo pode ser considerado curto para simula√ß√µes muito extensas.

-   Geradores modernos, como o **Mersenne Twister** (per√≠odo $2^{19937}-1$) ou a fam√≠lia **GCP (Gerador Congruencial Permutado)**, oferecem propriedades estat√≠sticas superiores.

üìå **Em resumo:** O Park‚ÄìMiller ainda √© excelente para fins did√°ticos e pequenas simula√ß√µes, mas para aplica√ß√µes cient√≠ficas de grande escala recomenda-se usar geradores mais robustos.
:::

Existem no `R` v√°rios algoritmos para geradores de n√∫meros pseudoaleat√≥rios. Para ver quais s√£o, basta:

```{r eval=FALSE}
help(Random)
```

![Imagem da documenta√ß√£o.](Captura%20de%20tela%20de%202025-09-07%2015-34-20.png){fig-align="center"}

## Uso de N√∫meros Aleat√≥rios na Avalia√ß√£o de Integrais

Uma das primeiras aplica√ß√µes do uso de n√∫meros aleat√≥rios foi na resolu√ß√£o de integrais. Considere uma fun√ß√£o $g(x)$ e suponha que desejamos calcular uma integral de interesse.

$$\theta = \int\limits_{0}^{1}g(x) dx.$$

Para calcular o valor da integral, observe que, se $U$ √© uma vari√°vel aleat√≥ria com distribui√ß√£o uniforme no intervalo $(0, 1)$, ent√£o podemos reescrever a integral da seguinte forma:

$$\theta = E[g(U)].$$ Se $U_1, U_2, \dots,  U_n$ s√£o vari√°veis aleat√≥rias independentes e uniformes em $(0, 1)$, ent√£o as vari√°veis $g(U_1), g(U_2), \dots,  g(U_n)$ s√£o indepedentes e identicamente distribu√≠das, todas com esperan√ßa igual $\theta$ (o valor da integral). Assim, pelo **Teorema da Lei Forte dos Grandes N√∫meros**, temos que, com probabilidade 1,

$$\frac{1}{n}\sum\limits_{i=1}^{n}g(U_i) \to \theta \quad \text{quando} \quad n \to \infty.$$

Assim, podemos aproximar o valor da integral gerando um grande n√∫mero de pontos aleat√≥rios $u_i$ no intervalo $(0, 1)$ e tomando como estimativa a m√©dia dos valores $g(u_i)$. Esse procedimento de aproxima√ß√£o de integrais √© conhecido como m√©todo de **Monte Carlo**.

Se quisermos calcular uma integral mais geral, podemos aplicar a mesma ideia: transformar o problema em uma esperan√ßa matem√°tica e, em seguida, aproxim√°-la por meio de m√©dias amostrais obtidas a partir de n√∫meros aleat√≥rios. Considere:

$$\theta = \int\limits_{a}^{b}g(x) dx.$$

Se quisermos calcular a integral em um intervalo gen√©rico $(a, b)$, fazemos a substitui√ß√£o

$$u = \frac{x - a}{b-a}, \quad du = \frac{dx}{b-a},$$

o que nos permite reescrev√™-la como

$$\theta = \int\limits_{a}^{b}g(x) dx = (b-a)\int\limits_{0}^{1}g(a + (b-a)u) du.$$

Definindo

$$h(u) = (b-a)g(a + (b-a)u),$$

temos

$$\theta = \int\limits_{0}^{1}h(u) du.$$

Assim, podemos aproximar $\theta$ gerando n√∫meros aleat√≥rios $u_1, u_2, \dots, u_n \sim U(0, 1)$ e tomando como estimativa a m√©dia

$$\frac{1}{n}\sum\limits_{i=1}^{n}h(u_i).$$ Agora, se nosso objetivo √© calcular a integral:

$$\theta = \int\limits_{0}^{\infty}g(x) dx.$$

Fazendo a mudan√ßa de vari√°vel

$$u = \frac{1}{x+1}, \quad du = \frac{-dx}{(x+1)^2} = -u^2 dx.$$

Logo,

$$dx = -\frac{du}{u^2},$$

e a integral resultante √©

$$\theta = \int\limits_{0}^{1}h(u) du,$$

com

$$h(u) = \frac{g\left(\frac{1}{u} - 1\right)}{u^2}.$$

A utilidade de empregar n√∫meros aleat√≥rios para aproximar integrais torna-se ainda mais evidente no caso de integrais multidimensionais. Suponha que $g$ seja uma fun√ß√£o com argumento $n$-dimensional e que estejamos interessados em calcular:

$$\theta = \int\limits_{0}^{1}\int\limits_{0}^{1}\dots\int\limits_{0}^{1} g(x_1, x_2, \dots, x_n)dx_1 dx_2 \dots dx_n.$$

Observe que $\theta$ pode ser expresso como o seguinte valor esperado:

$$\theta = E[g(U_1, U_2, \dots, U_n)],$$

em que $U_1, U_2, \dots, U_n$ s√£o vari√°veis aleat√≥ria independentes uniformente distribu√≠das no intervalo $(0, 1)$. Assim, se gerarmos $k$ conjuntos independentes, cada um formado por $n$ vari√°veis aleat√≥rias independentes com distribui√ß√£o uniforme em $(0, 1)$, ent√£o as vari√°veis

$$g(U_{i1}, U_{i2}, \dots, U_{in}), \quad i = 1, 2, \dots, k,$$ ser√£o independentes e identicamente distribu√≠das, todas com esperan√ßa igual a $\theta$ (o valor da integral). Portanto, podemos estimar $\theta$ por meio da m√©dia amostral:

$$\hat{\theta} = \frac{1}{k}\sum\limits_{i=1}^{k}g(U_{i1}, U_{i2}, \dots, U_{in}).$$

#### Exemplo {.unnumbered}

Nosso objetivo √© encontrar o valor aproximado da integral: $\int_{0}^{1} x^3 dx = 0.25.$

```{python}

```

```{R}
set.seed(2025) #fixando a semente
n <- 100000 #quantidade de valores uniformes gerados
u <- runif(n) #numeros uniformes (0,1)
mean(u^3)
```

```{python}
import numpy as np
np.random.seed(2025)
n = 100000
u = np.random.uniform(0, 1, n)
resultado = np.mean(u**3)

print(resultado)
```

#### Exerc√≠cios {.unnumbered}

1.  Se $x_0 = 5$ e $x_n = 3x_{n-1}\, \text{mod}\, 150$, encontre $x_1, x_2, \dots, x_{30}$.

2.  Se $x_0 = 3$ e $x_n = (5x_{n-1} + 7)\, \text{mod}\, 200$, encontre $x_1, x_2, \dots, x_{10}$.

3.  Compare sua estimativa com o valor exato:

-   $\int_{0}^{1} \exp\{{e^x}\} dx$.

-   $\int_{0}^{1} (1 - x^2)^{3/2} dx$.

-   $\int_{-2}^{2} \exp\{x + x^2\} dx$.

-   $\int_{0}^{\infty} x(1 + x^2)^{-2} dx$.

-   $\int_{-\infty}^{\infty} \exp\{-x^2\} dx$.

-   $\int_{0}^{1}\int_{0}^{1} \exp\{(x+y)^2\} dy dx$.

-   $\int_{0}^{\infty}\int_{0}^{x} \exp\{-(x+y)\} dydx$.

4.  Use simula√ß√£o para encontrar o valor aproximado de $Cov(U, e^U)$, em que $U$ √© uniforme em $(0,1)$. Compare seu resultado com o valor exato.
