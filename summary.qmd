# Números Uniformes

As simulações, de modo geral, requerem uma base inicial formada por números aleatórios. Diz-se que uma sequência $R_1, R_2, \ldots$ é composta por números aleatórios quando cada termo segue a distribuição uniforme $U(0,1)$ e $R_i$ é independente de $R_j$ para todo $i \neq j$. Embora alguns autores utilizem o termo “números aleatórios” para se referir a variáveis amostradas de qualquer distribuição, aqui ele será usado exclusivamente para variáveis com distribuição $U(0,1)$.

## Geração de sequências $U(0,1)$

Uma abordagem é utilizar dispositivos físicos aleatorizadores, como máquinas que sorteiam números de loteria, roletas ou circuitos eletrônicos que produzem “ruído aleatório”. Contudo, tais dispositivos apresentam desvantagens:

1.  **Baixa velocidade** e dificuldade de integração direta com computadores.
2.  **Necessidade de reprodutibilidade** da sequência. Por exemplo, para verificação de código ou comparação de políticas em um modelo de simulação, usando a mesma sequência para reduzir a variância da diferença entre resultados.

Uma forma simples de obter reprodutibilidade é armazenar a sequência em um dispositivo de memória (HD, CD-ROM, livro). De fato, a RAND Corporation publicou *A Million Random Digits with 100 000 Random Normal Deviates* (1955). Entretanto, acessar armazenamento externo milhares ou milhões de vezes torna a simulação lenta.

Assim, a abordagem preferida é **gerar números pseudoaleatórios em tempo de execução**, via recorrências determinísticas sobre inteiros. Isso permite:

-   Geração rápida;
-   Eliminação do problema de armazenamento;
-   Reprodutibilidade controlada.

Entretanto, a escolha inadequada da recorrência pode gerar sequências com baixa qualidade estatística.



### Geradores Congruenciais Lineares {.unnumbered}

Um **Gerador Congruencial Linear (LGC)** produz uma sequência de inteiros não negativos $X_i$, $i = 1, 2, \ldots$, por meio da relação de recorrência:

$$X_i = (a X_{i-1} + c) \bmod m, \quad i = 1, 2, \ldots,$$ em que $a > 0$ é o multiplicador, $X_0 \ge 0$ é a *semente* (*seed*), $c \ge 0$ é o incremento e $m > 0$ é o módulo.

Os valores $a, c, X_0$ estão no intervalo $[0, m-1]$. O número pseudoaleatório $R_i$ é obtido por:

$$R_i = \frac{X_i}{m}, \quad R_i \in (0,1).$$

Se $m$ for suficientemente grande, os valores discretos $0/m, 1/m, \ldots, (m-1)/m$ são tão próximos que $R_i$ pode ser tratado como variável contínua.

#### Exemplo {.unnumbered}

Seja o gerador:

$$X_i = (9 X_{i-1} + 3) \bmod 24, \quad i \geq 1.$$

Escolhendo $X_0 = 3$:

$$X_1 = (9 \times 3 + 3) \bmod 24 = 14$$

$$X_2 = (9 \times 14 + 3) \bmod 24 = 1$$

e assim por diante.

A sequência $R_i = X_i / 24$ gerada terá período $\ell = 24$.

#### Implementação em R {.unnumbered}

```{r}
# Função LCG genérica
lcg <- function(a, c, m, seed, n) {
  x <- numeric(n)
  x[1] <- seed
  for (i in 2:n) {
    x[i] <- (a * x[i-1] + c) %% m
  }
  r <- x / m
  return(list(X = x, R = r))
}

# Exemplo com a = 9, c = 3, m = 24, seed = 3
resultado <- lcg(a = 9, c = 3, m = 24, seed = 3, n = 20)
resultado$X
resultado$R
```

### Geradores Congruenciais Lineares Mistos {.unnumbered}

Nos LCGs **mistos** temos $c>0$. Uma escolha prática é $m = 2^b$, onde $b$ é o número de bits utilizável para inteiros positivos na arquitetura/linguagem. Em muitos ambientes, inteiros usam 32 bits (um para o sinal), implicando $b=31$ e intervalo $[-2^{31}, 2^{31}-1]$.

Quando $m=2^b$, obtemos **período completo** ($\ell=m$) se:

1)  $c$ é **ímpar** (garante $\gcd(c,m)=1$);\
2)  $a-1$ é múltiplo de todos os fatores primos de $m$ e também de 4 (como $m$ é potência de 2).

Essa é a razão de geradores simples com $m=2^b$, $c$ ímpar e $a \equiv 1 \pmod 4$ atingirem $\ell=m$.

### Questão de estouro e aritmética modular {.unnumbered}

Em linguagens com inteiros limitados, calcular $aX_{i-1}+c$ pode **transbordar**. Soluções comuns:

-   usar precisão estendida (64 bits) ou bibliotecas de inteiros grandes;
-   empregar **truques de aritmética modular** (como o método de Schrage) para evitar overflow;
-   trabalhar com módulo $m=2^b$ e aproveitar o “wrap” de bits.

A seguir, implementamos LCG misto com $m=2^{31}$, $a=906185749$, $c=1$. Parâmetros com boas propriedades estatísticas relatadas na literatura.

#### Implementação em R (com segurança de overflow) {.unnumbered}

Para garantir a correção do módulo com inteiros grandes, usaremos `bit64` (inteiros de 64 bits) e normalizaremos para $(0,1)$.

```{r}
#| label: lcg-misto
#| message: false
#| warning: false
#if (!requireNamespace("bit64", quietly = TRUE)) {
#  install.packages("bit64")
#}

library(bit64)

lcg_misto <- function(n, seed = 3456L,
                      a = 906185749L,
                      c = 1L,
                      m = bit64::as.integer64(2)^31) {
  # Trabalha em integer64 para evitar perda de precisão
  x <- bit64::as.integer64(seed)
  outX <- bit64::integer64(n)
  outR <- numeric(n)
  outX[1] <- x
  outR[1] <- as.double(x) / as.double(m)
  for (i in 2:n) {
    x <- (bit64::as.integer64(a) * x + bit64::as.integer64(c)) %% m
    outX[i] <- x
    outR[i] <- as.double(x) / as.double(m)
  }
  list(X = outX, R = outR)
}

# Exemplo: primeiros 5 números com seed = 3456
set.seed(NULL)
g1 <- lcg_misto(n = 5, seed = 3456L)
g1$X
g1$R
```

### Geradores Congruenciais Lineares Multiplicativos {.unnumbered}

No caso **multiplicativo**, temos $c = 0$, e a recorrência fica:

$$
X_i = (a X_{i-1}) \bmod m
$$

### Características e restrições {.unnumbered}

-   Se $X_i = 0$ em algum passo, toda a sequência futura será zero — portanto $X_0 \neq 0$.
-   Se $a = 1$, a sequência é constante — também deve ser evitado.
-   O **período máximo** possível é $m - 1$, e ele só é atingido quando:
    1.  $m$ é primo;
    2.  $a$ é uma **raiz primitiva** módulo $m$.

### Definição de raiz primitiva {.unnumbered}

Um número $a$ é raiz primitiva módulo $m$ se seus poderes geram todos os inteiros não nulos módulo $m$.\
Matematicamente, $a$ satisfaz:

$$
m \nmid a^{(m-1)/q} - 1, \quad \forall q \text{ primo que divide } m-1
$$

Esse tipo de gerador é chamado **Gerador de Módulo Primo e Período Máximo**.

------------------------------------------------------------------------

### Exemplo de implementação em R {.unnumbered}

A seguir, implementamos um gerador multiplicativo com módulo primo $m = 2^{31} - 1$ (primo de Mersenne) e multiplicador $a = 630360016$, conhecido por apresentar boas propriedades estatísticas.

```{r}
#| label: lcg-multiplicativo-gmp
#| message: false
#| warning: false
if (!requireNamespace("gmp", quietly = TRUE)) {
  install.packages("gmp")
}
library(gmp)

lcg_mult_primo <- function(n, seed, a = 630360016, m = 2147483647) {
  A <- as.bigz(a); M <- as.bigz(m)
  x <- as.bigz(seed)
  X <- integer(n); R <- numeric(n)
  for (i in seq_len(n)) {
    X[i] <- as.integer(x)    
    R[i] <- as.numeric(x) / m    
    x <- (A * x) %% M            
  }
  list(X = X, R = R)
}

# Exemplo: gerar 10 valores
g2 <- lcg_mult_primo(n = 10, seed = 12345L)
g2$X
g2$R
```

## Uso de Números Aleatórios na Avaliação de Integrais 

Uma das primeiras aplicações do uso de números aleatórios foi na resolução de integrais. Considere uma função $g(x)$ e suponha que desejamos calcular uma integral de interesse.

$$\theta = \int\limits_{0}^{1}g(x) dx.$$

Para calcular o valor da integral, observe que, se $U$ é uma variável aleatória com distribuição uniforme no intervalo $(0, 1)$, , então podemos reescrever a integral da seguinte forma:

$$\theta = E[g(U)].$$ Se $U_1, U_2, \dots,  U_n$ são variáveis aleatórias independentes e uniformes em $(0, 1)$, então as variáveis $g(U_1), g(U_2), \dots,  g(U_n)$ são indepedentes e identicamente distribuídas, todas com esperança igual $\theta$ (o valor da integral). Assim, pelo **Teorema da Lei Forte dos Grandes Números**, temos que, com probabilidade 1,

$$\frac{1}{n}\sum\limits_{i=1}^{n}g(U_i) \to \theta \quad \text{quando} \quad n \to \infty.$$

Assim, podemos aproximar o valor da integral gerando um grande número de pontos aleatórios $u_i$ no intervalo $(0, 1)$ e tomando como estimativa a média dos valores $g(u_i)$. Esse procedimento de aproximação de integrais é conhecido como método de **Monte Carlo**.

Se quisermos calcular uma integral mais geral, podemos aplicar a mesma ideia: transformar o problema em uma esperança matemática e, em seguida, aproximá-la por meio de médias amostrais obtidas a partir de números aleatórios. Considere:

$$\theta = \int\limits_{a}^{b}g(x) dx.$$

Se quisermos calcular a integral em um intervalo genérico $(a, b)$, fazemos a substituição

$$u = \frac{x - a}{b-a}, \quad du = \frac{dx}{b-a},$$

o que nos permite reescrevê-la como

$$\theta = \int\limits_{a}^{b}g(x) dx = (b-a)\int\limits_{0}^{1}g(a + (b-a)u) du.$$

Definindo

$$h(u) = (b-a)g(a + (b-a)u),$$

temos

$$\theta = \int\limits_{0}^{1}h(u) du.$$

Assim, podemos aproximar $\theta$ gerando números aleatórios $u_1, u_2, \dots, u_n \sim U(0, 1)$ e tomando como estimativa a média

$$\theta \approx \frac{1}{n}\sum\limits_{i=1}^{n}h(u_i).$$ Agora, se nosso objetivo é calcular a integral:

$$\theta = \int\limits_{0}^{\infty}g(x) dx.$$

Fazendo a mudança de variável

$$u = \frac{1}{x+1}, \quad du = \frac{-dx}{(x+1)^2} = -u^2 dx.$$

Logo,

$$dx = -\frac{du}{u^2},$$

e a integral resultante é

$$\theta = \int\limits_{0}^{1}h(u) du,$$

com

$$h(u) = \frac{g\left(\frac{1}{u} - 1\right)}{u^2}.$$

A utilidade de empregar números aleatórios para aproximar integrais torna-se ainda mais evidente no caso de integrais multidimensionais. Suponha que $g$ seja uma função com argumento $n$-dimensional e que estejamos interessados em calcular:

$$\theta = \int\limits_{0}^{1}\int\limits_{0}^{1}\dots\int\limits_{0}^{1} g(x_1, x_2, \dots, x_n)dx_1 dx_2 \dots dx_n.$$

Observe que $\theta$ pode ser expresso como o seguinte valor esperado:

$$\theta = E[g(U_1, U_2, \dots, U_n)],$$

em que $U_1, U_2, \dots, U_n$ são variáveis aleatória independentes uniformente distribuídas no intervalo $(0, 1)$. Assim, se gerarmos $k$ conjuntos independentes, cada um formado por $n$ variáveis aleatórias independentes com distribuição uniforme em $(0, 1)$, então as variáveis

$$g(U_{i1}, U_{i2}, \dots, U_{in}), \quad i = 1, 2, \dots, k,$$ serão independentes e identicamente distribuídas, todas com esperança igual a $\theta$ (o valor da integral). Portanto, podemos aproximar $\theta$ por meio da média amostral:

$$\theta \approx \frac{1}{k}\sum\limits_{i=1}^{k}g(U_{i1}, U_{i2}, \dots, U_{in}).$$
