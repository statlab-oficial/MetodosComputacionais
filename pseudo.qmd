# N√∫meros Pseudoaleat√≥rios - Caso Discreto

## M√©todo da Transforma√ß√£o Inversa


Suponha que desejamos gerar o valor de uma vari√°vel aleat√≥ria discreta $X$ com fun√ß√£o de massa de probabilidade (f.m.p):

$$\Pr(X = x_j) = p_j, \quad j = 0, 1, \dots, \quad \text{e} \quad \sum\limits_j p_j = 1.$$

Para realizar isso, gere um valor $u$ de $U\sim(0,1)$ e atribua o valor $x_j$, $j=0,1,\ldots$, a $X$ conforme as condi√ß√µes abaixo:

$$X = \begin{cases}
x_0, & \text{se } u < p_0, \\
x_1, & \text{se } p_0 \leq u < p_0+p_1, \\
x_2, & \text{se } p_0+p_1 \leq u < p_0+p_1+p_2, \\
x_3, & \text{se } p_0+p_1+p_2 \leq u < p_0+p_1+p_2+p_3, \\
\vdots & \\
x_j, & \text{se } \displaystyle \sum_{i=0}^{j-1} p_i \leq u < \sum_{i=0}^{j} p_i, \\
\vdots &
\end{cases}$$

Como, para $0 < a < b < 1, \Pr(a \leq U < b) = b-a$, temos que:

$$\Pr(X = x_j) = \Pr\left(\sum\limits_{i=0}^{j-1}p_i \leq U < \sum\limits_{i=0}^{j}p_i\right) = p_j,$$ e, portanto, $X$ possui a distribui√ß√£o desejada.

::: {.callout-important icon="false" appearance="simple"}
## Observa√ß√µes:

1.  Algoritmo - O procedimento anterior pode ser escrito como:

Passo 1. Gerar um valor $u \sim U(0,1)$.

Passo 2. Se $u < p_0$, ent√£o $X = x_0$; caso contr√°rio:

- se $u < p_0 + p_1$, ent√£o $X = x_1$; caso contr√°rio:\
- se $u < p_0 + p_1 + p_2$, ent√£o $X = x_2$; caso contr√°rio:\
    $\vdots$

Passo 3. Repetir os passos 1 e 2 $n$ vezes, onde $n$ √© o tamanho da amostra.

2.  Se os valores, $x_i, i \geq 0$, s√£o ordenados de modo que $x_0 < x_1 < \dots,$ e de denotamos $F$ como fun√ß√£o de distribui√ß√£o de $X$, ent√£o $F(x_j) = \sum\limits_{i=1}^{j}p_i$. Assim,

$$X\; \text{ser√° igual a}\; x_j\; \text{se}\; F(x_{j-1}) \leq U < F(x_j).$$
:::

Em outras palavras, ap√≥s gerar um n√∫mero aleat√≥rio $U$, determinamos o valor de $X$ encontrando o intervalo $[F(x_{j-1}), F(x_j))$ no qual $U$ se encontra (ou, de forma equivalente, encontrando o inverso de $F(U)$). √â por essa raz√£o que o procedimento acima √© denominado *m√©todo da transformada inversa discreta* para gerar $X$.

::: callout-note
O tempo necess√°rio para gerar uma vari√°vel aleat√≥ria discreta por esse m√©todo √© proporcional ao n√∫mero de intervalos que devem ser pesquisados. Por essa raz√£o, √†s vezes √© vantajoso considerar os poss√≠veis valores $x_j$ de $X$ em ordem decrescente das probabilidades $p_j$.
:::

### Exemplo 1 {.unnumbered}

Simular $n$ valores de $X$ tal que $p_1 = 0.20$, $p_2 = 0.15$, $p_3 = 0.25$, $p_4 = 0.40$, em que $p_j = P(X=j)$.

::: {.callout-warning icon="false" appearance="simple"}
## Algoritmo 1

Passo 1. Gerar $n$ valores $u \sim U(0,1)$.

Passo 2. Para cada $u$:

-   Se $u < 0.20$, ent√£o $X = 1$.

-   Caso contr√°rio, se $u < 0.35$, ent√£o $X = 2$.

-   Caso contr√°rio, se $u < 0.60$, ent√£o $X = 3$.

-   Caso contr√°rio ($u \geq 0.60$), ent√£o $X = 4$.

Passo 3. Repetir $n$ vezes os passos 1 e 2.
:::

A seguir, s√£o apresentados dos c√≥digos escritos na linguagem `R`:

```{r}
# Proposta 1
n <- 10000
x <- 1:4 
p <- c(0.20, 0.15, 0.25, 0.40)
pa <- cumsum(p) # probabilidades acumuladas
a  <- c() # vetor para a amostra gerada de X

for(i in 1:n){
  u <- runif(1)
  if (u < pa[1]) {
    a[i] <- x[1]
  } else { 
      if (u < pa[2]) {
        a[i] <- x[2]
      } else { if (u < pa[3]) {
        a[i] <- x[3]
      } else { 
          a[i] <- x[4]
          }
      }
    }
}
table(a)/n # tabela de propor√ß√µes

```

```{r}
# Proposta 2
n <- 10000; 
x <- 1:4; 
p <- c(0.20, 0.15, 0.25, 0.40)
pa <- cumsum(p) # probabilidades acumuladas
a  <- c() # vetor para a amostra gerada de X
		
for(i in 1:n){
  u = runif(1)
  ifelse(u < pa[1], a[i] <- x[1], 
    ifelse(u < pa[2], a[i] <- x[2],
      ifelse(u < pa[3], a[i] <- x[3], a[i] <- x[4])))
}
table(a)/n # tabela de propor√ß√µes
```

::: {.callout-warning icon="false" appearance="simple"}
## Algoritmo 2

Passo 1. Gerar um valor $u \sim U(0,1)$.

Passo 2. Para cada $u$:

-   Se $u < 0.40$, ent√£o $X = 4$;

-   Caso contr√°rio, se $u < 0.65$, ent√£o $X = 3$;

-   Caso contr√°rio, se $u < 0.85$, ent√£o $X = 1$;

-   Caso contr√°rio $u \geq 0.85$, ent√£o $X = 2$.

Passo 3. Repetir $n$ vezes os passos 1 e 2.
:::

::: {.callout-important icon="false"}
## üîé **Observa√ß√£o**:

A proposta 2 usa a **ordem decrescente** dos $p_j$ para otimizar a busca.
:::

::: {.callout-warning icon="false" appearance="simple"}
## Algoritmo 3 (mudando as desigualdades)

Passo 1. Gerar $u \sim U(0,1)$.

Passo 2. Se $u \leq 0.40$, ent√£o $X = 4$;

-   sen√£o, se $u \leq 0.65$, ent√£o $X = 3$;

-   sen√£o, se $u \leq 0.85$, ent√£o $X = 1$;

-   sen√£o ($u > 0.85$), ent√£o $X = 2$.

Passo 3. Repetir $n$ vezes os passos 1‚Äì2.
:::

::: {.callout-important icon="false"}
## üîé **Observa√ß√£o**:

Com $u \sim U(0,1)$ √© cont√≠nua, usar $<$ ou $\leq$ √© equivalente em termos de distribui√ß√£o (a probabilidade de $u$ cair exatamente no ponto de corte √© zero). Em implementa√ß√£o num√©rica, essa escolha apenas define para onde v√£o rar√≠ssimos empates nos pontos cortes.
:::


Se voc√™ deseja simular valores de $X$ com distribui√ß√£o uniforme discreta:

$$\Pr(X=j)=1/k, \quad j=1,2,3,\ldots, k.$$

Basta utilizar a Proposi√ß√µes 1 ou a Proposi√ß√£o 2.

::: {.callout-note .prop-blue icon="false"}
## Proposi√ß√£o 1:

Gere $U\sim U(0,1)$. Defina $X=j$ se

$$\frac{j-1}{k}\leq U < \frac{j}{k},$$ ou, equivalentemente,

$$(j-1)\leq kU < j.$$
:::

::: {.callout-note .prop-blue icon="false"}
## Proposi√ß√£o 2:

Gere $U\sim U(0,1)$. Defina $X=\lfloor kU  \rfloor +1$, em que $\lfloor z  \rfloor$ √© o maior inteiro menor ou igual a $z$.
:::

### Exemplo 2 {.unnumbered}

Para simular valores de $X$ com $\Pr(X=j)=1/10, \, \,\, j=1,2,3,\ldots, 10$, voc√™ pode serguir o procedimento a seguir:

| $U$ | $k\,U$  | [$X=\lfloor k\,U \rfloor +1$]{style="color:red"} |
|------------|------------|------------|
|  0,01 | 0,1 |  1 |
|  0,31 | 3,1 |  4 |
|  0,53 | 5,3 |  6 |
|  0,92 | 9,2 |  10 |
|  0,45 | 4,5 |  5 |
| $\vdots$ | $\vdots$ | $\vdots$ |
|  0,74 | 7,4 | 8 |

#### Exerc√≠cios {.unnumbered}

1.  Gerar uma permuta√ß√£o dos n√∫meros $1,2,3, \ldots, n$, considerando todas as $n!$ poss√≠veis permuta√ß√µes igualmente prov√°veis.

2.  Gerar valores de $X\sim \mbox{Geom√©trica}(p)$.

3.  Implementar o algoritmo para gerar valores de $X\sim \mbox{Poisson}(\lambda)$.

4.  Implementar o algoritmo para gerar valores de $X\sim \mbox{Binomial}(n,p)$.

### Exemplo 3 {.unnumbered}

Nosso objetivo agora √© gerar valores de $X\sim \mbox{Poisson}(\lambda)$ com:

$$p_i=\Pr(X=i)=\dfrac{e^{-\lambda}\lambda^i}{i!}, \quad i=0,1,2,\ldots. $$ 

::: {.callout-important icon="false"} 
## üîé **Identidade importante:**

$$p_{i+1} = \dfrac{\lambda}{i+1}p_i, \quad i\geq 0.$$
:::

Uma forma bastante utilizada para gerar valores de uma vari√°vel aleat√≥ria $X\sim \mbox{Poisson}(\lambda)$ √© por meio de algoritmos de simula√ß√£o baseados na identidade acima.

::: {.callout-warning icon="false" appearance="simple"}
## Algoritmo 4

Passo 1. Gerar um n√∫mero aleat√≥rio $u \sim U(0,1)$.

Passo 2. Inicializar $i = 0$, $p = e^{-\lambda}$, $F = p$.

Passo 3. Se $u < F$, ent√£o definir $X = i$ e parar.

Passo 4. Caso contr√°rio:

-   atualizar $i \leftarrow i+1$,

-   atualizar $p \leftarrow \frac{\lambda}{i}\,p$,

-   atualizar $F \leftarrow F + p$,

-   voltar ao passo 3.
:::

#### Exerc√≠cio {.unnumbered}

Complete o c√≥digo `R` abaixo:

```{r eval=FALSE}
N = 10^5 # tamanho da amostra
L = 3  # lambda
x = c()
for (j in 1:N){
  u = runif(1)
  i = 0; p = exp(-L); F = p
  aceito = "n√£o"
  while (aceito != "sim"){
    if(u < F) {
  	   ...
  	 } else {
        ...
      }
  }
}
```

### Exemplo 4 {.unnumbered}

Por fim, iremos gerar valores da vari√°vel aleat√≥rio $X$, $X\sim \mbox{Binomial}(n,p)$, com f.m.p dada por:

$$\Pr(X=i)=\dfrac{n!}{i!(n-i)!}p^i(1-p)^{n-i}, \quad i=0,1,2,\ldots,n.$$


::: {.callout-important}
## Identidade importante:

$$\Pr(X=i+1) = \dfrac{n-i}{i+1}\dfrac{p}{1-p}\Pr(X=i).$$
:::


A partir do resultado acima e do m√©todo da transforma√ß√£o inversa podemos escrever o seguinte algoritmo:

::: {.callout-warning appearance="simple" icon="false"}
## Algoritmo 5

Passo 1. Gerar um n√∫mero aleat√≥rio $u \sim U(0,1)$.

Passo 2. Calcular $k = \dfrac{p}{1-p}$, inicializar $i = 0$, $p_r = (1-p)^n$, $F = p_r$.

Passo 3. Se $u < F$, definir $X = i$ e parar.

Passo 4. Caso contr√°rio:

-   atualizar $p_r \leftarrow \dfrac{n-i}{i+1}\,k\,p_r$,

-   atualizar $F \leftarrow F + p_r$,

-   atualizar $i \leftarrow i+1$,

-   voltar ao passo 3.
:::

### Exerc√≠cio 5 {.unnumbered}

Escreve um c√≥digo na linguagem `R` baseado no Algoritmo 5. Utilize alguma ferramenta gr√°fica para verificar a coer√™ncia dos resultados.

## M√©todo da Aceita√ß√£o-Rejei√ß√£o

Suponha que haja interesse em simular valores de uma v.a. $X$ e que n√£o seja poss√≠vel inverter a sua fun√ß√£o de distribui√ß√£o ou n√£o dispomos de um m√©todo para gerar dessa vari√°vel aleat√≥ria. Entretanto, sabemos como simular de uma outra v.a. $Y$ e que √© poss√≠vel estabelecer uma rela√ß√£o entre as probabilidades associadas √†s duas vari√°veis aleat√≥rias ($X$ e $Y$) de tal modo que valores de $Y$ possam ser admitidos como valores de $X$.

| $x$   | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
|-------|------|------|------|------|------|------|------|------|------|------|
| $p_x$ | 0,11 | 0,12 | 0,09 | 0,08 | 0,12 | 0,10 | 0,09 | 0,09 | 0,10 | 0,10 |

| $y$   | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
|-------|------|------|------|------|------|------|------|------|------|------|
| $q_y$ | 0,10 | 0,10 | 0,10 | 0,10 | 0,10 | 0,10 | 0,10 | 0,10 | 0,10 | 0,10 |

Contexto:

-   **Podemos**: simular valores de $Y$ com f.p. $q_j=\Pr(Y=j), j\geq 0$.
-   **Queremos**: simular valores de $X$ com f.p. \small  $p_j=\Pr(X=j), j\geq 0$.
-   **Proposta**: simular valor $y$ de $Y$ e aceitar esse valor para $X$ com probabilidade proporcional a $\dfrac{p_y}{q_y}$.

::: {.callout-warning appearance="simple" icon="false"}
## Algoritmo

Passo 1. Simular $y$ de $Y$ com f.m.p. $q_y$.

Passo 2. Gerar $u \sim U(0,1)$.

Passo 3. Se $u < \dfrac{p_y}{c \, q_y}$, ent√£o aceite $X = y$. Caso contr√°rio, rejeite e n√£o atribua valor a $X$.

Passo 4. Repetir os passos 1‚Äì3 at√© obter o tamanho de amostra desejado.
:::

O algoritmo aceita√ß√£o-rejei√ß√£o gera uma v.a. $X$ tal que $\Pr(X=j)=p_j$, $j=0,1,2,\ldots$. Al√©m disso, o n√∫mero de itera√ß√µes que o algoritmo necessita para obter $X$ √© uma v.a. geom√©trica com m√©dia $c$.

::: {.callout-note icon="false" appearance="simple"}
## Prova do Teorema

1.  Em uma itera√ß√£o, determinar a probabilidade de gerar e ser aceito o valor $j$: 

$$\Pr(Y=j,\text{aceitar})= \Pr(Y=j) \cdot \Pr(\text{aceitar}\mid Y=j)= q_j\cdot \dfrac{pj}{cq_j} = \dfrac{p_j}{c}.$$
2.  Calcular a probabilidade de aceitar um valor $j$ gerado:

$$\Pr(\text{aceitar})= \sum_j \Pr(Y=j,\text{aceitar})=\sum_j \dfrac{p_j}{c} = \dfrac{1}{c}.$$
3.  Como cada itera√ß√£o independentemente resulta um valor aceit√°vel com probabilidade $\frac{1}{c}$, o n√∫mero de itera√ß√µes necess√°rias segue uma geom√©trica de m√©dia $c$. Portanto,

$$\Pr(X=j)=\! \sum_n P(\text{j aceito na itera√ß√£o $n$}) = \sum_n \left(1-\dfrac{1}{c}\right)^{n-1}\cdot\dfrac{p_j}{c}=p_j.$$
:::

::: {.callout-important icon="false"}
## Observa√ß√µes

-   A constante $c$ est√° relacionada com o n√∫mero de intera√ß√µes necess√°rias at√© a aceita√ß√£o de um valor de $Y$ para $X$.

-   O valor $c$ deve ser o menor poss√≠vel.

-   O valor de $c$ ser√° o $\mbox{max}\left\{\dfrac{p_y}{q_y}\right\}$.
:::

::: callout-note
$$u<\dfrac{p_y}{c\cdot q_y} \ \ \ \ \mbox{e}  \ \ \ \  P(U<\dfrac{p_y}{c\cdot q_y})= \dfrac{p_y}{c\cdot q_y} $$ $$\Downarrow$$ $$\dfrac{p_y}{c.q_y}\leq 1 \ \ \ \ \mbox{para todo} \ \ y \ \ \mbox{tal que} \ \ p_y>0$$ $$\Downarrow$$ $$c=\mbox{max}\left\{\dfrac{p_y}{q_y}\right\}$$
:::

#### Exemplo 1 {.unnumbered}

Gerar um valor da vari√°vel aleat√≥ria $X$ com f.m.p.:

| $j$   | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
|-------|------|------|------|------|------|------|------|------|------|------|
| $p_j$ | 0,11 | 0,12 | 0,09 | 0,08 | 0,12 | 0,10 | 0,09 | 0,09 | 0,10 | 0,10 |

Considerando que sabemos gerar de uma v.a. uniforme discreta, assumiremos $Y$ com distribui√ß√£o

$$\Pr(Y=j)=q_j=\dfrac{1}{10}; \quad j=1,2, \ldots, 10.$$

A constante $c$ ser√° determinada por $c=\mbox{max}\left\{\dfrac{p_j}{q_j}\right\} =\dfrac{0,\!12}{0,\!10}=1,\!2.$

::: {.callout-warning appearance="simple" icon="false"}
## Algoritmo

1.  Simular $y$ de $Y$: gere $u_1 \sim U(0,1)$ e fa√ßa $y = \mathrm{Int}(10u_1)+1$.
2.  Gerar um segundo n√∫mero aleat√≥rio $u_2$.
3.  Se $u_2 < \dfrac{p_y}{0.12}$, fa√ßa $X=y$ e pare. Caso contr√°rio, retorne ao passo 1.
:::

::: callout-note
Suponha $y=1$. Ent√£o, se $u_2<\dfrac{p_1}{0,\!12}=\dfrac{0,\!11}{0,\!12}=0,\!9167$, faremos $X=1$. Isto √©, assumiremos que o valor 1 gerado √© plaus√≠vel de ser da distribui√ß√£o de $X$. O gr√°fico a seguir ilustra esse processo.
:::

```{r}
#set.seed(20252)
pseudo_x <- NULL
for(i in seq_len(1000)){
  
pj <- c(0.11, 0.12, 0.09, 0.08, 0.12, 0.10, 0.09, 0.09, 0.10, 0.10)

u1 <- runif(1)
y <- floor(10*u1) + 1


repeat{
u2 <- runif(1)
x <- y

if(u2 < pj[y]/0.12) break
}

pseudo_x[i] <- x
}

round(prop.table(table(pseudo_x)),2)
```

Existe algum problema com os resultados acima? Se sim, fa√ßa a corre√ß√£o do c√≥digo e verifique graficamente a coer√™ncia dos resultados.

::: {.callout-important icon="false"}
## Observa√ß√µes

-   $91,\!67\%$ de todos os valores 1 gerados de $Y$ ser√£o aceitos

-   $100\%$ dos valores 2 gerados de $Y$ ser√£o aceitos

-   $75\%$ dos valores 3 gerados de $Y$ ser√£o aceitos

-   Qualquer valor da constante $c$ inferior a $1,\!2$ impossibilita gerar a distribui√ß√£o de $X$

-   Qualquer valor da constante $c$ superior a $1,\!2$ tornaria o processo mais lento para a obte√ß√£o da amostra
:::

#### Exerc√≠cios {.unnumbered}

1.  Gere n√∫meros pseudoaleat√≥rios de $X$ considerando $c = 2,4$.

2.  Compare com os resultados obtidos no Exemplo.

## M√©todo da Composi√ß√£o

Suponha que tenhamos um m√©todo eficiente para simular o valor de uma vari√°vel aleat√≥ria com f.m.p. ${p_j, ; j \geq 0}$ ou ${q_j, ; j \geq 0}$, e que desejamos simular a vari√°vel aleat√≥ria $X$ com f.m.p.:

$$\Pr(X = j) = \alpha p_j + (1 - \alpha)q_j, \quad j \geq 0, 0 < \alpha < 1.$$ Se $X_1 \sim {p_j}$ e $X_2 \sim {q_j}$, ent√£o podemos definir

$$X =
\begin{cases}
X_1, & \text{com probabilidade } \alpha, \\
X_2, & \text{com probabilidade } 1-\alpha ,
\end{cases}.$$

Assim, $X$ ter√° exatamente a fun√ß√£o de probabilidade acima.

#### Exemplo {.unnumbered}

Suponha que desejamos gerar o valor de uma vari√°vel aleat√≥ria $X$ tal que

$$p_j = \Pr(X = j) =  \begin{cases}
0.05, & \text{para}\quad j = 1, 2, 3, 4, 5, \\
0.15, & \text{para}\quad  j = 6, 7, 8, 9, 10,
\end{cases}$$

Note que $p_j = 0.5 \times p_j^{(1)} + 0.5 \times p_j^{(2)},$ em que

$$p_j^{(1)} = 0.1, \quad j = 1, \dots, 10 \quad \text{e} \quad p_j^{(2)} = \begin{cases}
0, & \text{para}\quad j = 1, 2, 3, 4, 5, \\
0.2, & \text{para}\quad  j = 6, 7, 8, 9, 10,
\end{cases}$$

podemos realizar essa simula√ß√£o gerando primeiro um n√∫mero aleat√≥rio $U \sim U(0,1)$ e ent√£o:

-   Se $U < 0.5$, gerar $X$ de uma uniforme discreta sobre $\{1,2,\dots,10\}$.
-   Caso contr√°rio ($U \geq 0.5$), gerar $X$ de uma uniforme discreta sobre $\{6,7,8,9,10\}$.

::: {.callout-warning appearance="simple" icon="false"}
## Algoritmo

Passo 1. Gerar $U_1 \sim U(0,1)$.

Passo 2. Gerar $U_2 \sim U(0,1)$.

Passo 3. Se $U_1 < 0.5$, definir $X = \mathrm{Int}(10U_1)+1$. Caso contr√°rio, definir $X = \mathrm{Int}(5U_2)+6$.
:::

Se $F_i$, $i=1,\dots,n$ s√£o fun√ß√µes de distribui√ß√£o e $\alpha_i$, $i=1,\dots,n$ s√£o n√∫meros n√£o negativos cuja soma √© 1, ent√£o a fun√ß√£o de distribui√ß√£o:

$$
F(x) = \sum_{i=1}^n \alpha_i F_i(x),
$$

√© uma **mistura**, ou uma **composi√ß√£o**, das fun√ß√µes de distribui√ß√£o $F_i$, $i = 1, \dots, n$.

Uma maneira de simular a partir de $F$ √© primeiro simular uma vari√°vel aleat√≥ria $I$, igual a $i$ com probabilidade $\alpha_i$, $i=1,\dots,n$, e ent√£o simular a partir da distribui√ß√£o $F_I$ (Isto √©, se o valor simulado de $I$ for $I = j$, ent√£o a segunda simula√ß√£o √© feita a partir de $F_j$). Essa abordagem para simular de $F$ √© frequentemente chamada de **m√©todo de composi√ß√£o**.
